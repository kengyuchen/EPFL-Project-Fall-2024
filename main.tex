%%%%%%%%%%%%%%%%%%%%

% Semester Project Fall 2024 for EPFL
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Semester Project}
\fancyhead[C]{Biometric Authentication}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------

This project formalizes the biometric authentication scheme, including its structure, usage, and security analysis with a security game model.

%-------------------

\section{Preliminaries}
\label{sec:preliminaries}

In this project, we assume

\begin{itemize}
	
	\item $\lambda$ is the security parameter.

	\item $[m]$ denotes the set of integers $\{1, 2, \cdots, m\}$.

	\item $\Z_q$ is the finite field modulo a prime number $q$.

	\item A function $f(n)$ is called \emph{negligible} iff for any integer $c$, $f(n) < \frac{1}{n^c}$ for all sufficiently large $n$. We write it as $f(n) = \negl$, and we may also use $\negl$ to represent an arbitrary negligible function.
	
	\item $\poly$ is the class of polynomial funcions. We may also use $\poly$ to represent an arbitrary polynomial function.
	
	\item We write sampling a value $r$ from a distribution $\mathcal{D}$ as $r \getsdollar \mathcal{D}$. If $S$ is a finite set, then $r \getsdollar S$ means sampling $r$ uniformly from $S$.

	\item The distribution $\mathcal{D}^t$ denotes $t$ identical and independent distributions of $\mathcal{D}$.

	\item A PPT algorithm denotes a probabilistic polynomial time algorithm. Unless otherwise specified, all algorithms run in PPT.

\end{itemize}

We introduce three types of inner product functional encryption schemes: function hiding functional encryption, two-input functional encryption, and two-client functional encryption. We will instantiate our biometric authentication scheme using these primitives.

\begin{definition}[Function Hiding Inner Product Functional Encryption]
\label{def:fh-IPFE}
	A \emph{function hiding inner product functional encryption} (fh-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$: It outputs the public parameter $\textsf{pp}$ and the master secret key $\textsf{msk}$.
	
		\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$: It generates the functional decryption key $f_\mathbf{x}$ for an input vector $\mathbf{x} \in \mathbb{F}^k$. 
	
		\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$: It encrypts the input vector $\mathbf{y} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_y}$. 
	
		\item $\textsf{FE.Dec}(\textsf{pp}, f_\mathbf{x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$ or an error symbol $\bot$.
	
	\end{itemize}
	
	\noindent \textbf{Correctness}: The fh-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$ and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}( \textsf{pp}, \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}), \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) ) = \mathbf{x} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using an fh-IPFE scheme is given in Section \ref{sec:fh-IPFE-instantiation}.

\begin{definition}[Two-Input Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2i-IPFE}
	A \emph{two-input inner product functional encryption} (2i-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent \textbf{Correctness}: The 2i-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, and $\mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have

	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2i-IPFE is given in Section \ref{sec:2i-IPFE-instantiation}.

\begin{definition}[Two-Client Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2c-IPFE}
	A \emph{two-client inner product functional encryption} (2c-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\ell, \textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given a label $\ell$ and an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent \textbf{Correctness}: The 2c-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, label $\ell$, and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2c-IPFE is given in Section \ref{sec:2c-IPFE-instantiation}.

We also consider an instantiation using a relational hash scheme.

\begin{definition}[Relational Hash (adapted from \cite{cryptoeprint:2014/394})]
\label{def:rh}
	Let $R_\lambda$ be a relation over sets $X_\lambda, Y_\lambda$, and $ Z_\lambda$. A \emph{relational hash} scheme \textsf{RH} for $R_\lambda$ consists of PPT algorithms \textsf{RH.KeyGen}, $\textsf{RH.HASH}_1$, $\textsf{RH.HASH}_2$, and \textsf{RH.Verify}:
	
	\begin{itemize}
	
		\item $\textsf{RH.KeyGen}(1^\lambda) \to \textsf{pk}$: It outputs a public hash key \textsf{pk}.  
			
		\item $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$: Given a hash key \textsf{pk} and $\mathbf{x} \in X_\lambda$, it outputs a hash $\mathbf{h_x}$.

		\item $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$: Given a hash key \textsf{pk} and $\mathbf{y} \in Y_\lambda$, it outputs a hash $\mathbf{h_y}$.

		\item $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}, \mathbf{z}) \to r \in \{0, 1\}$: Given a hash key \textsf{pk}, two hashes $\mathbf{h_x}$ and $\mathbf{h_y}$, and $\mathbf{z} \in Z_\lambda$, it verifies whether the relation among $\mathbf{x}, \mathbf{y}$ and $\mathbf{z}$ holds.

	\end{itemize}

	\noindent \textbf{Correctness}: The relational hash scheme \textsf{RH} is \emph{correct} if $\forall \mathbf{x}, \mathbf{y}, \mathbf{z} \in X_\lambda \times Y_\lambda \times Z_\lambda$,
	\[
		\Pr \left [
			\begin{aligned} 
				 &\; \textsf{pk} \gets \textsf{RH.KeyGen}(1^\lambda) \\
				 &\; \mathbf{h_x} \gets \textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \\
				 &\; \mathbf{h_y} \gets \textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y})
			\end{aligned} :
			\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}, \mathbf{z}) = R(\mathbf{x}, \mathbf{y}, \mathbf{z})
			\right ] = 1 - \negl.
	\]
\end{definition}
Note that $Z_\lambda$ is an auxiliary input. When the relation $R$ is over two sets $X \times Y$, we ignore $Z$ and write $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y})$.


Instantiation using a relational hash is given in Section \ref{sec:rh-instantiation}.


%-------------------


\section{Formalization}
\label{sec:formalization}


In general, an authentication shceme $\Pi$ associated with a family of biometric distributions $\mathbb{B}$ is composed of the following algorithms.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda) \to \textsf{esk}, \textsf{psk}, \textsf{csk}$: It outputs the enrollment secret key $\textsf{esk}$, probe secret key $\textsf{psk}$, and compare secret key $\sf csk$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{x}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{x}$, the input format for enrollment. We write $\textsf{encodeEnroll}(\mathbf{b}) \to \mathbf{x}$ when $\textsf{encodeEnroll}$ only has one biometric template vector $\mathbf{b}$ to generate $\mathbf{x}$. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x}) \to \mathbf{c_x}$: It outputs the enrollment message $\mathbf{c_x}$ from $\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{y}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{y}$, the input format for probe. We write $\textsf{encodeProbe}(\mathbf{b}^\prime) \to \mathbf{y}$ when $\textsf{encodeProbe}$ only has one biometric template vector $\mathbf{b}^\prime$ to generate $\mathbf{y}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y}) \to \mathbf{c_y}$: It outputs the probe message $\mathbf{c_y}$ from $\mathbf{y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)} \to s$: It compares the enrollment message $\mathbf{c_x}$ and probe message $\mathbf{c_y}$ and outputs a score $s$.

	\item $\textsf{Verify}(s) \to r \in \{0,1\}$: It is a deterministic algorithm that reads the comparison score $s$ and determines whether this is a successful authentication ($r = 1$) or not ($r = 0$).

\end{itemize}

\noindent 
We discuss two usage models that employs the authentication scheme $\Pi$.


%-------------------


\subsection{Usage Model – Device-of-User}
\label{sec:dou_model}

In the model described in Figure \ref{fig:model_dou_overview} (an overview), Figure \ref{fig:model_dou_enrollment} (on enrollment), and Figure \ref{fig:model_dou_auth} (on authentication), users authenticate themselves to a server through their own devices and biometric scanners that are shared among different users.
A key distribution service distributes keys for them. In practice, this model applies to the situation when the users access an online service run by the server.

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$. 

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Device}: A device belonging to the user. In practice, it can be a desktop or a mobile phone. It processes the \textsf{Enroll} and \textsf{Probe} functions for $\textsf{User}$ with keys \textsf{esk} and \textsf{psk}. It queries $\mathcal{O}_{\mathcal{B}}$ for biometric data through the \textsf{Scanner}.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to $\textsf{Device}$ and $\textsf{Server}$.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}

The Device-of-User model, when instantiated by an fh-IPFE scheme (Section \ref{sec:fh-IPFE-instantiation}), is analogous to the use case presented in \cite{cryptoeprint:2023/481}.
In their model, a user possesses a personal device, such as a smartphone or laptop, and a secure hardware device that runs an initial setup and stores all the keys, which corresponds to our \textsf{KDS}.
On enrollemnt and authentication, the user inputs biometric templates onto the device, which corresponds to our \textsf{Scanner}.
Subsequently, the device transmits the template to the secure hardware for the enrollment or probing processes, which are equivalent to our \textsf{Device}.
In addition, they incorporate a two-factor authentication mechanism.
The secure hardware also executes a digital signature scheme and sign the probe message on authentication.


\input{tikz/dou_model.tex}

%-------------------

\subsection{Usage Model – Device-of-Domain}
\label{sec:dod_model}

In the model described in Figure \ref{fig:model_dod_overview} (an overview), Figure \ref{fig:model_dod_enrollment} (on enrollment), and Figure \ref{fig:model_dod_auth} (on authentication), users first enroll themselves at an enrollment station and then authenticate themselves to a server through devices that belong to a domain.
A key distribution service distributes enrollment keys to the enrollment station, probe keys to the domain, and comparison keys to the server. In practice, a domain can be a department in an organization, and this models applies to the situation when a user wants to access a public service of a department, such as a restricted area or instruments. 

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data at an enrollment station and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$.
	
	\item \textsf{Domain}: A domain that owns several devices, all of which share one enrollment key $\textsf{esk}$, one probe key $\textsf{psk}$ and one comparison key $\textsf{csk}$. Only the probe key is stored at each device of a domain. The enrollment key is stored at the enrollment station, and the comparison key is stored at the server. In practice, a domain can be a department, and users enroll and authenticate themselves before accessing a restricted service of this department.

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Station}: An enrollment station responsible for collecting the user's biometric data to enroll them for a domain on the server.

	\item \textsf{Device}: A device belonging to a domain. In practice, it can be a device checking identities for a restricted area or an instrument. It owns a probe key $\sf psk$ and processes the $\sf Probe$ function for enrolled users of this domain.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to \textsf{Station}, \textsf{Domain}, and \textsf{Server}.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} for each domain and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}


%-------------------

\input{tikz/dod_model.tex}

\pagebreak

%-------------------

\subsection{Instantiation with an fh-IPFE Scheme}
\label{sec:fh-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be an fh-IPFE scheme we defined in Definition \ref{def:fh-IPFE}. Following \cite{cryptoeprint:2023/481}, we can instantiate a biometric authentication scheme using $\textsf{FE}$ with the distance metric the Euclidean distance. Let the biometric distribution $\mathcal{B} \subseteq [m]^k$, and let the associated field of $\textsf{FE}$ be $\mathbb{Z}_q$ where $q$ is a prime number larger than the maximum possible Euclidean distance $m^2 \cdot k$. The scheme is instantiated as follows.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$ and outputs $\textsf{esk} \gets (\textsf{msk}, \textsf{pp})$, $\textsf{psk} \gets (\textsf{msk}, \textsf{pp})$ and $\textsf{csk} \gets \textsf{pp}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b} = (b_1, b_2, \cdots, b_k)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{x} = (x_1, x_2, \cdots, x_{k+2}) = (b_1, b_2, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$ and outputs $\mathbf{c_x} \gets f_\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime = (b_1^\prime, b_2^\prime, \cdots, b_k^\prime)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{y} = (y_1, y_2, \cdots, y_{k+2}) = (-2b_1^\prime, -2b_2^\prime, \cdots, -2b_k^\prime, \|\mathbf{b}^\prime\|^2, 1)$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{y}^T = \sum_{i=1}^k -2b_ib_i^\prime + \|\mathbf{b}\|^2 + \|\mathbf{b}^\prime\|^2 = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]

which is the square of the Euclidean distance between two templates $\mathbf{b}$ and $\mathbf{b}^\prime$. Therefore, if two templates $\mathbf{b}$ and $\mathbf{b}^\prime$ are close enough such that $\|\mathbf{b} - \mathbf{b}^\prime\| \leq \tau$, the scheme results in $r = 1$, a successful authentication.


Instantiated with an fh-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is public, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are the same. Anyone with access to the enrollment message $\mathbf{c_x}$ and either one of $\textsf{esk}$, $\textsf{psk}$, or a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot )$ can probe some $\mathbf{y}^{\prime} \in \Z_q^{k+2}$ and find $\mathbf{x} {\mathbf{y}^\prime}^T$ to get partial or full information about $\mathbf{x}$. Even if the adversary can only sample random ciphertexts $\mathbf{c_{y}}$ without knowing $\mathbf{y}$, if the field size $q$ is not large enough, one can find a forged $\mathbf{c_{y^*}}$ such that $\mathbf{x}\mathbf{y^*}^T \leq \tau$ to impersonate the user by sampling many times offline.


Therefore, \textsf{Server} must store $\mathbf{c_x}$ securely, to avoid such an attack from an adversary who can access the probe oracle; \textsf{Device} must protect its probe function, to avoid such an attack from a malicious \textsf{Server}. 

In the Device-of-Domain model, we assume the probe oracle is public, just as everyone can try accessing a public service. A malicious \textsf{Station} or \textsf{Server}, who has the enrollment message $\mathbf{c_x}$, can utilize this attack to retrieve information about \textsf{User}.


%-------------------


\subsection{Instantiation with a 2i-IPFE Scheme}
\label{sec:2i-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2i-IPFE scheme we defined in Definition \ref{def:2i-IPFE}. Following the scheme in Section \ref{sec:fh-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $ \textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. It outputs $\textsf{esk} \gets \textsf{ek}_1$, $\textsf{psk} \gets \textsf{ek}_2$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:fh-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \mathbf{x} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:fh-IPFE-instantiation}


Unlike the previous scheme, instantiated with a 2i-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is now secret, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are distinct. Without $\textsf{csk}$, one cannot compare an enrollment message $\mathbf{c_x}$ and a probe message $\mathbf{c_y}$. We can also transmit $\mathbf{c_x}$ in a public channel and store it in a public storage, under necessary security requirements of the 2i-IPFE scheme, such as indistinguishability of $\mathbf{c_x}$.

In the Device-of-Domain model, the indistinguishability of $\mathbf{c_x}$ is against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$. If \textsf{Server} is malicious, then it can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ enrolled by different samples. Therefore, we must limit the adversary's ability. For example, we can require the adversary to distinguish biometric vectors sampled from distributions in a pre-defined pool, and the adversary can only probe vectors randomly sampled from a distribution in the pool. We can also limit the rate of the probe oracle.

%-------------------

\subsection{Instantiation with a 2c-IPFE Scheme}
\label{sec:2c-IPFE-instantiation}

Note that if labels remain constant, a 2c-IPFE scheme is reduced to a 2i-IPFE scheme. Therefore, we can consider utilizing the label to represent each domain in the Device-of-Domain model. Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2c-IPFE scheme we defined in Definition \ref{def:2c-IPFE}. Following the scheme in Section \ref{sec:2i-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $\textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. For keys used for \textsf{Domain} $\ell$, it outputs $\textsf{esk} \gets (\ell, \textsf{ek}_1)$, $\textsf{psk} \gets (\ell, \textsf{ek}_2)$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$.

	Note that when the previous 2i-IPFE-based scheme in Section \ref{sec:2i-IPFE-instantiation} is applied to a Device-of-Domain model, we assume that $\textsf{Setup}$ is run once for each domain to generate different $\textsf{esk}, \textsf{psk}, \textsf{csk}$. In the scheme in this section, however, $\textsf{Setup}$ is run only once for all the domains, and each domain shares the same $\textsf{csk}$ and the same $\textsf{esk}, \textsf{psk}$ except different labels.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:2i-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, if the labels of $\mathbf{c_x}$ and $\mathbf{c_y}$ are the same (they are of the same domain), we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:2i-IPFE-instantiation}

When the Device-of-Domain model is instantiated with a 2c-IPFE scheme in this way, the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are now shared among all the devices, regardless of their domains. Therefore, to let a malicious or broken \textsf{Domain} not threaten other honest ones, one needs to make sure given $\textsf{esk}$ or $\textsf{psk}$, $\mathbf{c_x}$ still does not leak information about $\mathbf{x}$. This is different from the scheme in Section \ref{sec:2i-IPFE-instantiation}, where we only need seurity against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$.

If \textsf{Server} and \textsf{Domain} are both malicious, then the adversary can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ and even recover $\mathbf{x}$. Therefore, we assume at most one party of them can be malicious at the same time. Note that this is the same as the 2i-IPFE-based scheme, where only one of \textsf{Server} and \textsf{Domain} can be malicious.

%-------------------

\subsection{Instantiation with a Relational Hash Scheme}
\label{sec:rh-instantiation}

Let $\textsf{RH} = (\textsf{RH.KeyGen}, \textsf{RH.Hash}_1, \textsf{RH.Hash}_2, \textsf{RH.Verify})$ be a relational hash scheme we defined in Definition \ref{def:rh} for the relation $R^\tau$ of Hamming distance proximity parametrized by a constant $\tau$.
\[
	R^\tau = \{ (\mathbf{x}, \mathbf{y}) \mid \textsf{HD}(\mathbf{x}, \mathbf{y}) \leq \tau \wedge \mathbf{x}, \mathbf{y} \in \{0,1\}^k \}
\]
Note that here we ignore the third parameter $Z$.
Following \cite{cryptoeprint:2014/394}, we can instantiate a biometric authentication scheme using $\textsf{RH}$.  Let the biometric distribution $\mathcal{B} \subseteq \{0,1\}^k$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{RH.KeyGen}(1^\lambda) \to \textsf{pk}$ and outputs $\textsf{esk} \gets \textsf{pk}$, $\textsf{psk} \gets \textsf{pk}$, and $\textsf{csk} \gets \textsf{pk}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}$ sampled from $\mathcal{O}_\mathcal{B}$, it direclty outputs $\mathbf{x} \gets \mathbf{b}$.

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$ and outputs $\mathbf{c_x} \gets \mathbf{h_x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime$ sampled from $\mathcal{O}_\mathcal{B}$, it directy outputs $\mathbf{y} \gets \mathbf{b}^\prime$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$ and outputs $\mathbf{c_y} \gets \mathbf{h_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: It direclty returns $r \gets s$.

\end{itemize}

By the correctness of the relational hash scheme $\textsf{RH}$, we have (except for a negligible probability),
\[
	r = 1 \Leftrightarrow (\mathbf{x}, \mathbf{y}) \in R^\tau \Leftrightarrow \textsf{HD}(\mathbf{b}, \mathbf{b}^\prime) \leq \tau
\]


%-------------------


\section{Security Games}
\label{sec:security_game}

To rigorously analyze the security of an authentication scheme, we simulate biometric distributions of users by assuming the existence of a family $\mathbb{B}$ of distributions. We require that all distributions in $\mathbb{B}$ are efficiently samplable and has an excessively large size for a PPT adversary to enumerate. We then provide interfaces for all algorithms to interact with $\mathbb{B}$.

\begin{itemize}

	\item $\textsf{BioSamp}()$: Generate a random distribution $\mathcal{B}$ of $\mathbb{B}$. By this we mean providing either parameters of an efficiently samplable distribution or a PPT algorithm as the sampler. For simplicity, we write $\mathcal{B} \gets \textsf{BioSamp}()$ as $\mathcal{B} \getsdollar \mathbb{B}$.
	
	\item $\textsf{BioDelete}(\mathcal{B})$: Delete $\mathcal{B}$ from $\mathbb{B}$. Consequently, no further access to $\textsf{BioSamp}$ can derive $\mathcal{B}$. For simplicity, we write $\textsf{BioDelete}(\mathcal{B})$ as $\mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$.
	\item $\textsf{TempSamp}(\mathcal{B})$: Let $\mathcal{B}$ be a biometric distribution in $\mathbb{B}$. This algorithm samples a biometric template from $\mathcal{B}$. For simplicity, we write $\mathbf{b} \gets \textsf{TempSamp}(\mathcal{B})$ as $\mathbf{b} \getsdollar \mathcal{B}$.

	\item $\mathcal{O}_\textsf{samp}(\cdot)$: On input an index $i$,
	\begin{itemize}
		\item If $i$ was not queried before, it first samples a biometric distribution $\mathcal{B}_i \in \mathbb{B}$ by $\textsf{BioSamp}$ and then outputs a biometric template sampled from the distribution $\mathcal{B}_i$, denoted by $\mathbf{b} \getsdollar \mathcal{B}_i$.
		\item If $i$ has been queried before, it outputs a biometric template sampled from the distribution $\mathcal{B}_i$, denoted by $\mathbf{b} \getsdollar \mathcal{B}_i$.
	\end{itemize}
\end{itemize}


%-------------------

\subsection{Unforgeability}
\label{sec:uf_game}

To describe the unforgeability of an authentication scheme, we model the ability of an adversary who tries to impersonate \textsf{User}. The adversary $\mathcal{A}$ is given auxiliary information \textsf{option} that depends on our threat model. The adversary tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game $\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}$ is defined in Algorithm \ref{alg:uf_game}.

\begin{figure}[h]
\centering
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:uf_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$
		
		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$
		
		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A} ( \textsf{option} )$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:uf_game}
\end{figure}

The auxiliary information \textsf{option} can be nothing or include $\mathbf{c_x}, \textsf{esk}, \textsf{psk}, \textsf{csk}$ or the following oracles:

\begin{itemize}

	\item $\mathcal{O}_{\mathcal{B}}$: It outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}$. This oracle and $\textsf{psk}$ should not be given at the same time.
	
	\item $\mathcal{O}_\textsf{Enroll}(\textsf{esk}, \cdot)$: On input $\mathbf{x}^\prime$, it outputs the enrollment message $\textsf{Enroll}(\textsf{esk}, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}(\textsf{psk}, \cdot)$: On input $\mathbf{y}^\prime$, it outputs the probe message $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime)$. If this oracle and $\mathcal{O}_{\mathcal{B}}$ are given at the same time, we require the adversary to return some $\mathbf{\tilde{z}}$ that is not equal to any previous answer of $\mathcal{O}_\textsf{Probe}$.
	
	\item $\mathcal{O}_\textsf{log}^{Q}(\textsf{csk}, \mathbf{c_x}, \cdot)$: This is a resource-limited oracle. If it has been queried over $Q$ times in total, it aborts. Otherwise, on input $\mathbf{z}$, it first computes $\mathbf{c_z} \gets \textsf{Probe}(\textsf{psk}, \textsf{encodeProbe}(\mathbf{z}))$ and outputs $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_z} ) )$. We omit $Q$ in the superscript when we allow unbounded number of queries. 
	
	\item $\mathcal{O}_\textsf{Enroll}^\prime (\cdot)$: On input $\textsf{esk}^\prime$, it first samples $\mathbf{x}^\prime \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Enroll}(\textsf{esk}^\prime, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}^\prime (\cdot)$: On input $\textsf{psk}^\prime$, it first samples $\mathbf{y}^\prime \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Probe}(\textsf{psk}^\prime, \mathbf{y}^\prime)$. This oracle and $\textsf{psk}$ should not be given at the same time. 
	
\end{itemize}

If $\textsf{option}$ does not include $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$, or if $\textsf{option}$ includes $\mathcal{O}_\mathcal{B}$, we define the advantage of an adversary $\mathcal{A}$ with $\textsf{option}$ in the \textsf{UF} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1]
\]

When $\textsf{option}$ includes $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$, to consider potential non-negligible false positive rates of biometrics match, we define the plain $\textsf{UF}^\prime$ game in Algorithm \ref{alg:plain-uf_game}, where the adversary has only $\mathcal{O}_\textsf{log}^{Q}$ and tries to find a vector $\mathbf{\tilde{z}}$ close to $\mathbf{x}$.

\begin{figure}[H]
\centering
	\begin{minipage}[t]{0.5\linewidth}
	\begin{algorithm}[H]
	\caption{$\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime)$}
	\label{alg:plain-uf_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\prime \mathcal{O}_\textsf{log}^Q }()$

		\State $\mathbf{\tilde{c_z}} \gets \textsf{Probe}(\textsf{psk}, \textsf{encodeProbe}(\mathbf{\tilde{z}}))$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{c_z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
\label{fig:plain-uf_game}
\end{figure}

The advantage of an adversary $\mathcal{A}$ is defined as
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \max\{ \Pr[\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1], 0 \}.
\]

An authentication scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions is called \emph{\textsf{option}-unforgeable} (\textsf{option}-UF) if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} = \negl.
\]


For the rest of this project, if the scheme, the family distribution, and the auxiliary information $\textsf{option}$ are clear from context, we omit the subscript and write the game as $\textsf{UF}(\mathcal{A})$. This abbreviation also holds for all other games.


%-------------------


\subsection{Choice of \textsf{option} and True/False Positive Rates}
\label{sec:choice-of-option}

In this section, we detail possibilities of the auxiliary information $\textsf{option}$ in the $\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}$ game and rule out trivial attacks. We use the instantiation in Section \ref{sec:fh-IPFE-instantiation} as an example to illustrate.

For a biometric distribution $\mathcal{B} \in \mathbb{B}$ and $\mathbf{b} \getsdollar \mathcal{B}$, define the \emph{true positive rates} \textsf{TP}.
\begin{gather*}
	\textsf{TP}(\mathcal{B}, \mathbf{b}) := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau: \mathbf{b}^\prime \getsdollar \mathcal{B}] \\
	\textsf{TP}(\mathcal{B}) := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau: \mathbf{b}, \mathbf{b}^\prime \getsdollar \mathcal{B}] = \mathbb{E}_{\mathbf{b} \getsdollar \mathcal{B}}[\textsf{TP}(\mathcal{B}, \mathbf{b})] \\
	\textsf{TP} := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau:\mathcal{B} \getsdollar \mathbb{B}, \mathbf{b}, \mathbf{b}^\prime \getsdollar \mathcal{B}] = \mathbb{E}_{\mathcal{B}\getsdollar \mathbb{B}}[\textsf{TP}(\mathcal{B})] 
\end{gather*}
We also define \emph{false positive rates} \textsf{FP}.
\begin{gather*}
	\textsf{FP}(\mathbf{b}) := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau: \mathcal{B}^\prime \getsdollar \mathbb{B}, \mathbf{b}^\prime \getsdollar \mathcal{B}^\prime] \\
	\textsf{FP}(\mathcal{B}) := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau: \mathbf{b} \getsdollar \mathcal{B}, \mathcal{B}^\prime \getsdollar \mathbb{B}, \mathbf{b}^\prime \getsdollar \mathcal{B}^\prime] = \mathbb{E}_{\mathbf{b} \getsdollar \mathcal{B}}[\textsf{FP}(\mathbf{b})] \\
	\textsf{FP} := \Pr[ \| \mathbf{b} - \mathbf{b}^\prime\| \leq \tau: \mathcal{B}, \mathcal{B}^\prime \getsdollar \mathbb{B}, \mathbf{b} \getsdollar \mathcal{B}, \mathbf{b}^\prime \getsdollar \mathcal{B}^\prime] = \mathbb{E}_{\mathcal{B} \getsdollar \mathbb{B}}[\textsf{FP}(\mathcal{B})]
\end{gather*}
Ideally, we hope $\textsf{TP}$ to be close to $1$ and \textsf{FP} to be negligible for any $\mathcal{B}$. However, due to the nature of biometrics, $\textsf{FP}$ can be non-negligible.
The use of plain $\textsf{UF}^\prime$ game is to prevent an \textsf{UF} game adversary from leveraging a non-negligible \textsf{FP}.
If $\textsf{option}$ includes $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$, the $\textsf{UF}$ adversary $\mathcal{A}$ in Algorithm \ref{alg:adv:FP} can enjoy a winning rate of $\textsf{FP}$.
\begin{figure}[h]
\centering
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{A}(\textsf{psk})$ ( or $\mathcal{A}^{\mathcal{O}_\textsf{Probe}}$ ) }
	\label{alg:adv:FP}
	\begin{algorithmic}[1]
		\State $\mathcal{B}^\prime \getsdollar \mathbb{B}$
		
		\State $\mathbf{y} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^\prime }}()$

		\State $\mathbf{c_y} \gets \textsf{Probe}(\textsf{psk}, \mathbf{y})$ \Comment{or $\mathbf{c_y} \gets \mathcal{O}_\textsf{Probe}(\mathbf{y})$ }

		\State \Return $\mathbf{c_y}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

We note that an $\textsf{UF}^\prime$ adversary can have the same winning probability by returning $\mathbf{b}^\prime \getsdollar \mathcal{B}^\prime$. 
Moreover, to capture the circumstance when everyone, including the adversary, can try to log in, we provide the oracle $\mathcal{O}_\textsf{log}^Q$, which can boost the winning probability of an $\textsf{UF}^\prime$ adversary to around $Q \cdot \textsf{FP}$ if $\textsf{FP}(\mathbf{b})$ is small in general.
\[
\mathbb{E}_{\mathcal{B} \getsdollar \mathbb{B}, \mathbf{b} \getsdollar \mathcal{B}}[ 1 - (1 - \textsf{FP}(\mathbf{b}))^Q ] \approx \mathbb{E}_{\mathcal{B} \getsdollar \mathbb{B}, \mathbf{b} \getsdollar \mathcal{B}}[ Q \cdot \textsf{FP}(\mathbf{b}) ] = Q \cdot \textsf{FP}
\]
The scheme is considered secure when no \textsf{UF} adveraries can acquire a non-negligible advantage over this baseline.


If \textsf{option} includes $\mathcal{O}_\mathcal{B}$ and either $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$, the adversary can enjoy a winning rate \textsf{TP}, and therefore we rule out the case when $\textsf{option}$ includes both $\textsf{psk}$ and $\mathcal{O}_\mathcal{B}$, and we forbid the adversary from returning what $\mathcal{O}_\textsf{Probe}$ returns when $\textsf{option}$ includes both $\mathcal{O}_\textsf{Probe}$ and $\mathcal{O}_\mathcal{B}$.

If \textsf{option} includes $\textsf{csk}, \mathbf{c_x}$, and either $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$, the scheme cannot achieve UF security when \textsf{FP} is not negligible. An adversary can run $\mathbf{\tilde{z}} \gets \mathcal{A}$ for $\mathcal{A}$ in Algorithm \ref{alg:adv:FP} and $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}})$ to check if the answer is valid. By repeating this procedure $\poly$ times, its winning probability can be boosted to around $\poly \cdot \textsf{FP}$

If $\textsf{option}$ includes $\mathcal{O}_{\textsf{Enroll}}^\prime$ and either $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$, the adversary in Algorithm \ref{alg:adv:FP2} can win with a probability
\[
	\Pr[ \| \mathbf{b}^{(0)} - \mathbf{b}^\prime \| \leq \tau \mid  \| \mathbf{b}^{(1)} - \mathbf{b}^\prime \| \leq \tau]
\]
where $\mathbf{b}^{(0)}, \mathbf{b}^{(1)} \getsdollar \mathcal{B}$ and $\mathbf{b}^\prime \getsdollar \mathcal{B}^\prime$. This value is in general not negligible.
The expected number of repetitions is $\mathbb{E}_{\mathcal{B} \getsdollar \mathbb{B}}\left[\frac{1}{\textsf{FP}(\mathcal{B})} \right]$. If $\textsf{FP}(\mathcal{B})$ is non-negligible, the adversary can return the answer in an expected polynomial time. A similar adversary also exists when $\textsf{option}$ includes $\mathcal{O}_{\textsf{Probe}}^\prime$ and $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$.
 
\begin{figure}[h]
\centering
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{A}^{\mathcal{O}_\textsf{Enroll}^\prime}(\textsf{psk})$ (or  $\mathcal{A}^{\mathcal{O}_\textsf{Enroll}^\prime, \mathcal{O}_\textsf{Probe}}$ ) }
	\label{alg:adv:FP2}
	\begin{algorithmic}[1]
		\State $\textsf{esk}^\prime, \textsf{psk}^\prime, \textsf{csk}^\prime \gets \textsf{Setup}(1^\lambda)$

		\Repeat
		
			\State $\mathcal{B}^\prime \getsdollar \mathbb{B}$
		
			\State $\mathbf{y}^\prime \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^\prime }}()$ 

			\State $\mathbf{c_y}^\prime \gets \textsf{Probe}(\textsf{psk}^\prime, \mathbf{y}^\prime)$

			\State $\mathbf{c_x}^\prime \gets \mathcal{O}_\textsf{Enroll}^\prime (\textsf{esk}^\prime)$

		\Until{ $\textsf{Verify}(\textsf{Compare}(\textsf{csk}^\prime, \mathbf{c_x}^\prime, \mathbf{c_y}^\prime )) = 1$ }

		\State $\mathbf{c_y} \gets \textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime)$  \Comment{ or $\mathbf{c_y} \gets \mathcal{O}_\textsf{Probe}(\mathbf{y}^\prime)$ } 

		\State \Return $\mathbf{c_y}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}




%-------------------


\subsection{Indistinguishable against Malicious Server (IND-MSV)}
\label{sec:ind-msv_game}

In the game of Indistinguishable against Malicious Server, we model the ability of a malicious \textsf{Server} who tries to identify the user. The adversary $\mathcal{A}$ is given oracles to two biometric distributions $\mathcal{B}^{(0)}, \mathcal{B}^{(1)}$, the comparison key $\textsf{csk}$, an enrollment message $\mathbf{c_x}$, and a list of $t$ probe messages $\{ \mathbf{c_y}^{(i)} \}_{i=1}^t$ . It tries to guess from either $\mathcal{B}^{(0)}$ or $ \mathcal{B}^{(1)}$ these messages are generated. The whole game is defined in Algorithm \ref{alg:ind-msv_game}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.6\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{IND-MSV}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:ind-msv_game}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$

		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(b)}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\For{$i = 1$ to $t$}

			\State $\mathbf{y}^{(i)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(b)}}}() $
		
			\State $\mathbf{c_y}^{(i)} \gets \textsf{Probe}( \textsf{psk}, \mathbf{y}^{(i)} )$

		\EndFor

		%\State In Device-of-User Model:
		
			%\State \hspace{\algorithmicindent} $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}} } ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		%\State In Device-of-Domain Model:
		
			\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}} ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

%\caption{The \textsf{IND-MSV} Game}
\label{fig:ind-msv_game}
\end{figure}

%Note that in Device-of-Domain model, a probe oracle is given to the adversary.

%\begin{itemize}

	%\item $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$: On input an index $i$, it first samples $\mathbf{y}^\prime \getsdollar \textsf{encodeProbe}^{\mathcal{O}_{\textsf{samp}}(i)}$, which uses $\mathcal{O}_{\textsf{samp}}(i)$ to answer biometric queries, and outputs $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime )$. 

%\end{itemize}

%We provide $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$ instead of $\mathcal{O}_{\textsf{Probe}}(\textsf{psk}, \cdot)$. This is to avoid the trivial attack where the adversary probes samples from the oracles $\mathcal{O}_{\mathcal{B}^{(0)}}$ and $\mathcal{O}_{\mathcal{B}^{(1)}}$ and compare the results with $\mathbf{c_x}$.

We define the advantage of an adversary $\mathcal{A}$ in the \textsf{IND-MSV} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}} := \left |\Pr[\textsf{IND-MSV}_{\Pi}(\mathcal{A}) \to 1] - \frac{1}{2} \right|.
\]

An authentication scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions is called \emph{indistinguishable against malicious server (IND-MSV)} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}} = \negl.
\]

%-------------------
\newpage

\section{Security Analysis: fh-IPFE-based Instantiation}
\label{sec:security_analysis:fh-IPFE}

Let $\Pi$ be an authentication scheme instantiated by an fh-IPFE scheme \textsf{FE} as in Section \ref{sec:fh-IPFE-instantiation}. We discuss the UF and IND-MSV security of $\Pi$ in this section. For this, we first define two security notions of \textsf{FE}.

Given an fh-IPFE scheme \textsf{FE}, we define the \textsf{fh-IND} game \cite{cryptoeprint:2023/481} in Algorithm \ref{alg:ind-fh-IPFE}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.4\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ind-fh-IPFE}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}} ( \textsf{pp} )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ind-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}_{\textsf{KeyGen}}(\cdot, \cdot)$: On input pair $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^{(b)} )$.

	\item $\mathcal{O}_{\textsf{Enc}}(\cdot, \cdot)$: On input pair $(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^{(b)} )$.

\end{itemize}

\noindent To avoid trivial attacks, we consider \emph{admissible adversaries}.

\begin{definition}[Admissible Adversary]

	Let $\mathcal{A}$ be an adversary in an \textsf{fh-IND} game, and let $ (\mathbf{x}_1^{(0)}, \mathbf{x}_1^{(1)}), \cdots, (\mathbf{x}_{Q_K}^{(0)}, \mathbf{x}_{Q_K}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{KeyGen}}$ and $(\mathbf{y}_1^{(0)}, \mathbf{y}_1^{(1)}), \cdots, (\mathbf{y}_{Q_E}^{(0)}, \mathbf{y}_{Q_E}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{Enc}}$.
	We say $\mathcal{A}$ is \emph{admissible} if $\forall i \in [Q_K], \forall j \in [Q_E]$,
\[
	{\mathbf{x}^{(0)}_{i}} {\mathbf{y}^{(0)}_{j}}^T = {\mathbf{x}^{(1)}_{i}} {\mathbf{y}^{(1)}_{j}}^T
\]

\end{definition}


\begin{definition}[fh-IND Security]

	An fh-IPFE scheme \textsf{FE} is called fh-IND secure if for any admissible adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{fh-IND}$ game in Algorithm \ref{alg:ind-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{fh-IND}} := \left| \Pr[\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A}) \to 1 ] - \frac{1}{2} \right| = \negl.
\]

\end{definition}


We also define the \textsf{RUF} game in Algorithm \ref{alg:ruf-fh-IPFE} for a real number $\gamma$.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k}$ \label{alg:ruf-fh-IPFE:r}

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} } ( \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ruf-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$: On input $\mathbf{x}^\prime$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^\prime)$.
	
	\item $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$: On input $\mathbf{y}^\prime$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^\prime)$. The adversary is required to return $\mathbf{\tilde{z}}$ that is not equal to any output of this oracle.
\end{itemize}


\begin{definition}[RUF Security]

	An fh-IPFE scheme \textsf{FE} is called RUF secure for a real number $\gamma$ if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the \textsf{RUF} game in Algorithm \ref{alg:ruf-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} := \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\end{definition}


We note that by adding a sEUF-CMA signature scheme $\textsf{Sig} = ( \textsf{KeyGen}, \textsf{Sign}, \textsf{Verify} )$, an \textsf{fh-IPFE} scheme can be upgraded to an RUF secure scheme. In a bit more detail,

\begin{itemize}

	\item $\textsf{FE.Setup}$ also runs $\textsf{Sig.KeyGen}(1^\lambda)$ and generates the signature secret key $\textsf{sk}_{\textsf{Sig}}$ and the verification public key $ \textsf{pk}_{\textsf{Sig}}$. Let $\textsf{sk}_{\textsf{Sig}}$ be part of $\textsf{msk}$ and $\textsf{pk}_{\textsf{Sig}}$ be part of $\textsf{pp}$.

	\item $\textsf{FE.Enc}$ signs the encryption by $\textsf{sk}_{\textsf{Sig}}$.

	\item $\textsf{FE.Dec}$ outputs the decryption if the verification succeeds. Otherwise, it outputs $\bot$.

\end{itemize}

If the adversary manage to find a $\mathbf{\tilde{z}}$ that is not equal to any output of $\mathcal{O}_\textsf{Enc}^\prime$ and $\textsf{FE.Dec}$ on input $\mathbf{\tilde{z}}$ does not return $\bot$, the adversary is able to forge a valid signagure.


%-------------------


\subsection{UF Security}
\label{sec:security_analysis:fh-IPFE:uf}

We first consider \textsf{option}-UF security when $\textsf{option}$ includes $\mathcal{O}_\textsf{Enroll}$. Note that in this instantiation, $\textsf{csk}$ is the public parameter $\textsf{pp}$ of \textsf{FE} and assumed to be given to all adversaries. 

\begin{theorem}
\label{thm:ind-uf-OB-Enroll}
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_{\textsf{option}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Enroll} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{x}^\prime )$  by $\mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^\prime, \mathbf{x}^\prime)$ given in the \textsf{fh-IND} game.  Note that since $\mathcal{R}$ never calls $\mathcal{O}_{\textsf{Enc}}$, it is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Enroll:B}

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$ \label{alg:red:ind-uf-OB-Enroll:c}

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Enroll} } ( \mathbf{c}, \textsf{pp})$ \label{alg:red:ind-uf-OB-Enroll:A}

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Enroll:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

	If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_{\textsf{option}}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is $\Pr[\textsf{UF}_{\textsf{option}}(\mathcal{A}) \to 1]$.

	For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Enroll} in the $\textsf{RUF}$ game. $\mathcal{A}^\prime$ runs Line \ref{alg:red:ind-uf-OB-Enroll:B} and \ref{alg:red:ind-uf-OB-Enroll:A} of $\mathcal{R}$ and simulates $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{x}^\prime )$ by $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ given in the \textsf{RUF} game. 


\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
	\caption{${\mathcal{A}^\prime}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} }(\textsf{pp}, \mathbf{c})$}
	\label{alg:adv:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ 
		
		\State $\mathbf{\tilde{z}} \gets {\mathcal{A}}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{Enroll} } (\mathbf{c}, \textsf{pp})$

		\State \Return $\mathbf{\tilde{z}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

Now, if the challenge bit $b = 1$, then $\mathcal{R}$ perfectly simulates $\mathcal{A}^\prime$ in the $\textsf{RUF}$ game. The probability that $\textsf{Verify}(s) = 1$, which is equivalent to $s \leq \tau^2$, in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is $\Pr[\textsf{RUF}^{\tau^2}_{\textsf{FE}}(\mathcal{A}) \to 1 ]$

In conclusion, since $\gamma \geq \tau^2$,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 0] \right) \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 1] \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_{\textsf{option}}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}^{\tau^2}_{\textsf{FE}}(\mathcal{A}) \to 1 ] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}^{\gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] \right)
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ]$ are negligilbe,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \negl.
\]

\end{proof}


For $\textsf{option}$ that includes $\mathcal{O}_{\textsf{Probe}}$, we first note that for any $d \in \Z_q$ and any nonzero vector $\mathbf{r} \in \Z_q^{k+2}$, there exists a vector $\mathbf{y}$ such that $\mathbf{r}\mathbf{y}^T = d$.

\begin{theorem}
\label{thm:ind-uf-OB-Probe}

Let $\textsf{option} = \{\mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_\textsf{option}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Probe} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Probe}}$ in the following way.

\begin{itemize}

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}{\mathbf{y}^\prime}^T$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r}{\mathbf{y}^{\prime\prime}}^T = d$. Next, it calls $\mathcal{O}_{\textsf{Enc}}(\mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}})$, which is given by the \textsf{fh-IND} game, and returns the result.

\end{itemize}

\noindent Note that $(\mathbf{x}, \mathbf{r})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\mathbf{x}{\mathbf{y}^\prime}^T = \mathbf{r}{\mathbf{y}^{\prime\prime}}^T$. Hence, $\mathcal{R}$ is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Probe:B}

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$

		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c}, \textsf{pp})$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}_\textsf{Probe}$}

			\State \Return $\bot$

		\EndIf

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Probe:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_\textsf{option}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Probe:verify} is $\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1]$.

For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Probe} in the $\textsf{RUF}$ game. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates $\mathcal{O}_{\textsf{Probe}}$ in the following way.

\begin{itemize}

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}^{(*)}{\mathbf{y}^\prime}^T$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r}{\mathbf{y}^{\prime\prime}}^T = d$. Next, it calls $\mathcal{O}^\prime_{\textsf{Enc}} (\mathbf{y}^{\prime\prime} )$ , which is given by the $\textsf{RUF}$ game, and returns the result.

\end{itemize}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.8\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$ {\mathcal{A}^\prime}^{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} } (\textsf{pp}, \mathbf{c}) $}
	\label{alg:adv:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:adv:ind-uf-OB-Probe:B}
		
		\State $\mathbf{x}^{(*)} \gets \textsf{encodeEnroll}^{ \mathcal{O}_{\mathcal{B}} } ()$

		\State Sample $k+2$ linearly independent vectors $\{ \mathbf{e}^{(i)} \}_{i=1}^{k+2}$.

		\For{$i=1$ to $k+2$}
			\State $\mathbf{c}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

			\State $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c}^{(i)})$.
		\EndFor

		\State Find the vector $\mathbf{r}$ by solving the linear system $\{ \mathbf{r} {\mathbf{e}^{(i)}}^T = d_i \}_{i=1}^{k+2}$.

		\If{$\mathbf{r} = \mathbf{0}$}

			\State \Return $\bot$

		\EndIf

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c}, \textsf{pp})$
		
		\State \Return ${\mathbf{\tilde{z}}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

To make $\mathcal{R}$ simulate $\mathcal{A}^\prime$ in the $\textsf{RUF}$ game, we still need to ensure two conditions.

\begin{itemize}

	\item $\mathbf{r} \neq \mathbf{0}$. Otherwise, $\mathcal{A}^\prime$ cannot simulate $\mathcal{O}_\textsf{Probe}$. 

	\item $\mathbf{\tilde{z}} \neq \mathbf{c}^{(i)}$ for all $i$. The answers of $\mathcal{O}_\textsf{Probe}$ have already been checked in $\mathcal{R}$. 
\end{itemize}

Let $\mathcal{A}^\prime$ play a tweaked $\textsf{RUF}_\textsf{FE}^{\tau^2}$ game which does not check that $\mathbf{\tilde{z}}$ is not equal to $\mathbf{c}^{(i)}$ for all $i$. That is, the game only checks whether $\mathbf{\tilde{z}}$ is not equal to any output of $\mathcal{O}^\prime_\textsf{Enc}$ called by $\mathcal{O}_\textsf{Probe}$ of $\mathcal{A}$. Let the returned value of this game be $V$. We have Equation \ref{equ:ind-uf-OB-Probe:1} and \ref{equ:ind-uf-OB-Probe:2}. The former one is a relation between $\mathcal{R}$ playing $\textsf{fh-IND}$ game when the challenge bit $b=1$ and $V$, and the other one is a relation between $\mathcal{A}^\prime$ playing a regular $\textsf{RUF}_\textsf{FE}^{\tau^2}$ game and the tweaked one.

\begin{gather}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] = \Pr[V = 1] \label{equ:ind-uf-OB-Probe:1} \\
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] = \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right] \label{equ:ind-uf-OB-Probe:2}
\end{gather}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:1}, consider that

\begin{align*}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1]
	&= \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] \cdot \Pr[\mathbf{r} \neq \mathbf{0}] \\
	&+ \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} = \mathbf{0}] \cdot \Pr[\mathbf{r} = \mathbf{0}] \\
	&\leq \Pr[V = 1] + \Pr[\mathbf{r} = 0] \\
	&= \Pr[V = 1] + \frac{1}{q^{k+2}} 
\end{align*}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:2}, consider that

\begin{align*}
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] 
	&= \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right] \\ 
	& \geq \Pr[V = 1] - \Pr \left[ \neg  \left( \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right) \right] \\
	& = \Pr[V = 1] - \Pr \left[ \bigvee_{i=1}^{k+2} \mathbf{\tilde{z}} = \mathbf{c}^{(i)} \right] \\
	& \geq \Pr[V = 1] - \sum_{i=1}^{k+2} \Pr[\mathbf{\tilde{z}} = \mathbf{c}^{(i)}].
\end{align*}

\noindent Note that each $\mathbf{c}^{(i)} = \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{e}^{(i)})$ for some uniform nonzero vector $\mathbf{e}^{(i)}$. Also note that distinct vectors in $\Z_q^{k+2}$ will have different encryptions due to the correctness of $\textsf{FE}$. Therefore, $\Pr[\mathbf{\tilde{z}} = \mathbf{c}^{(i)}] \leq \frac{1}{q^{k+2} - 1}$ and
\[
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] \geq \Pr[V = 1] - \frac{k+2}{q^{k+2}-1}.
\]

\noindent Combining both results from Equation \ref{equ:ind-uf-OB-Probe:1} and \ref{equ:ind-uf-OB-Probe:2}, we derive
\[
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1] \leq \Pr[V = 1] + \frac{1}{q^{k+2}} \leq \Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}}.
\]

Finally, similar to the proof of Theorem \ref{thm:ind-uf-OB-Enroll}, we derive
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1]
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] - \frac{k+2}{q^{k+2}-1} - \frac{1}{q^{k+2}} \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}_\textsf{FE}^{\gamma}(\mathcal{A}^\prime) \to 1] - \frac{k+2}{q^{k+2}-1} - \frac{1}{q^{k+2}} \right) \\
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ]$ are negligible,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}} = \negl.
\]

\end{proof}

Unfortunately, for the instantiation in Section \ref{sec:fh-IPFE-instantiation}, we cannot achieve UF security when the adversary has $\mathcal{O}_\textsf{Probe}$ but no $\mathcal{O}_\mathcal{B}$; that is, the adversary can return what $\mathcal{O}_\textsf{Probe}$ returns as its answer. The adversary can simply ask $\mathbf{c} \gets \mathcal{O}_\textsf{Probe}(\mathbf{0})$ and return $\mathbf{c}$. While in some fh-IPFE constructions \cite{cryptoeprint:2015/1255, cryptoeprint:2016/440}, $\textsf{FE.Enc}$ disallows a zero input vector, the adversary can still ask $\mathbf{c} \gets \mathcal{O}_\textsf{Probe}(\mathbf{v})$, where $\mathbf{v} = (0, \cdots, 0, 1, 0)$ has only a single $1$ in the $k+1$-th coefficient, and win the game with probability $1$. The same results also hold for $\textsf{option}$ that includes $\textsf{esk}$ or $\textsf{psk}$ since they are equal to $\textsf{msk}$ and allow the adversary to run $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{v})$ for any vector $\mathbf{v}$. We state this result formally in the following theorem.

\begin{theorem}

Let $\textsf{option} = \{ \mathcal{O}_\textsf{Probe} \}$ (or $\{\textsf{esk}\}$, $\{\textsf{psk}\}$). For any distribution family $\mathbb{B}$ and functional encryption $\textsf{FE}$, $\Pi$ is not \textsf{option}-unforgeable.

\end{theorem}


%-------------------


\subsection{IND-MSV Security}
\label{sec:security_analysis:fh-IPFE:IND-MSV}

For the IND-MSV security, we first consider the following definition and assumption on the biometric distribution family $\mathbb{B}$.

\begin{definition}
For any distribution $\mathcal{B} \in \mathbb{B}$ and an integer $t$, define the distribution $\mathcal{D}_\mathcal{B}(t)$ as
\[
	\mathcal{D}_\mathcal{B}(t) = \left( \| \mathbf{b} - \mathbf{b}^{(1)} \|, \| \mathbf{b} - \mathbf{b}^{(2)} \|, \cdots, \| \mathbf{b} - \mathbf{b}^{(t)} \| \right)
\]
where $\mathbf{b}, \mathbf{b}^{(1)} \cdots, \mathbf{b}^{(t)} \getsdollar \mathcal{B}$.

\end{definition}

\begin{assumption}
\label{assump:equal_distance}
Let $t$ be an integer. Assume that for any two distributions $\mathcal{B}^{(0)}$ and $\mathcal{B}^{(1)}$ in the biometric distribution family $\mathbb{B}$, $\mathcal{D}_{ \mathcal{B}^{(0)} }(t)$ and $\mathcal{D}_{ \mathcal{B}^{(1)} }(t)$ are the same. 

\end{assumption}

Note that when $\Pi$ is instantiated by an fh-IPFE scheme as in Section \ref{sec:fh-IPFE-instantiation}, computational indistinguishability between $\mathcal{D}_{ \mathcal{B}^{(0)} }(t)$ and $\mathcal{D}_{ \mathcal{B}^{(1)} }(t)$ is a necessary condition to achieve IND-MSV security because
\[
	\left( \sqrt{ \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}^{(1)}) }, \cdots, \sqrt{ \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}^{(t)}) } \right) = \mathcal{D}_{ \mathcal{B}^{(b)} }(t)
\]
where $b$ is the challenge bit.




\begin{theorem}
For any distribution family $\mathbb{B}$ satisfying Assumption \ref{assump:equal_distance} and having a true positive rate $\textsf{TP} > \frac{1}{\poly}$, if \textsf{FE} is fh-IND secure, then $\Pi$ is IND-MSV secure.

\end{theorem}



\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{IND-MSV}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-ind-msv} which plays the \textsf{fh-IND} game by running $\mathcal{A}$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-ind-msv}
	\begin{algorithmic}[1]
		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$ \label{alg:red:ind-ind-msv:B0}
		
		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$ \label{alg:red:ind-ind-msv:B1}

		\State $\mathbf{x}^{(0)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$
		
		\State $\mathbf{x}^{(1)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$
		
		\State $\mathbf{c_x} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$ \label{alg:red:ind-ind-msv:cx}

		\For{$i = 1$ to $t$}
			
			\State $\mathbf{y}^{(0)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$

			\Repeat 

			\State $\mathbf{y}^{(1)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$

			\Until{ $\mathbf{x}^{(0)} {\mathbf{y}^{(0)}}^T = \mathbf{x}^{(1)} {\mathbf{y}^{(1)}}^T$ } \label{alg:red:ind-ind-msv:while}

				%\State $\mathbf{y}^{(1)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$

			%\EndWhile

			\State $\mathbf{c_y}^{(i)} \gets \mathcal{O}_{\textsf{Enc}}(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$ \label{alg:red:ind-ind-msv:cy}

		\EndFor

		\State $\tilde{b} \gets {\mathcal{A}}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}} } (\textsf{pp}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$ \label{alg:red:ind-ind-msv:A}

		\State \Return $\tilde{b}$

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

\noindent Note that $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^{(0)}, {\mathbf{y}^{(1)}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\mathbf{x}^{(0)}{\mathbf{y}^{(0)}}^T = \mathbf{x}^{(1)}{\mathbf{y}^{(1)}}^T$. Hence, $\mathcal{R}$ is an admissible adversary.

The probability that Line \ref{alg:red:ind-ind-msv:while} is satisfied is
\begin{align*}
	\Pr[\mathcal{D}_{\mathcal{B}^{(0)}}(1) = \mathcal{D}_{\mathcal{B}^{(1)}}(1)] 
	&\geq \sum_{i=0}^\tau \Pr[\mathcal{D}_{\mathcal{B}^{(0)}}(1) = i]^2 \qquad \text{(Assumption \ref{assump:equal_distance})} \\
	&\geq \frac{1}{\tau + 1} \cdot \left( \sum_{i=0}^\tau \Pr[\mathcal{D}_{\mathcal{B}^{(0)}}=i] \right)^2 \\
	&= \frac{1}{\tau + 1} \cdot \Pr[ \mathbf{b}, \mathbf{b}^\prime \getsdollar \mathcal{B}^{(0)} : \| \mathbf{b} - \mathbf{b}^\prime \| \leq \tau ] \\
	&= \frac{\textsf{TP}(\mathcal{B}^{(0)})}{\tau + 1} = \frac{\textsf{TP}}{\tau + 1} \qquad \text{(Assumption \ref{assump:equal_distance})} 
\end{align*}
The expected number of repetitions is bounded above by $\frac{\tau + 1}{ \textsf{TP} }$. Moreover, the probability that it is satisfied within $T$ repetitions is at least
\[
	1 - (1 - \frac{\textsf{TP}}{\tau + 1})^T \geq 1 - e^{-T \cdot \frac{\textsf{TP}}{\tau + 1}}
\]
We can reach a $1 - \negl.$ probability that the loop will end within $T$ times by setting a polynomial-size $T$.

Now, we show that $\mathcal{R}$ perfectly simulate an \textsf{IND-MSV} game for $\mathcal{A}$. If the challenge bit $b$ of the \textsf{fh-IND} game is $0$, $\mathbf{c_x}$ and $\mathbf{c_y}^{(i)}$ for all $i \in [t]$ are generated from $\mathcal{B}^{(0)}$ and have the same distributions as the inputs for an adversary in \textsf{IND-MSV} game.
If the challenge bit $b$ is $1$, we show that distributions of $\mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t$ also follow the same distribution given Assumption \ref{assump:equal_distance}.

Let $\mathbf{X}^{(0)}$ and $\mathbf{X}^{(1)}$ be the distribution of $\{ \mathbf{x}^{(0)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}} \}$ and $\{ \mathbf{x}^{(1)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}} \}$, respectively.
Let $\{ \mathbf{Y}^{(0)}_i \}_{i = 1}^t$ and $\{ \mathbf{Y}^{(1)}_i \}_{i = 1}^t$ be $t$ identical and independent distributions of $\{ \mathbf{y}^{(0)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(0)}}} \}$ and $\{ \mathbf{y}^{(1)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(1)}}} \}$, respectively.
Let $\mathbf{Y}^\prime_i$ be the distribution of $\mathbf{y}^{(1)}$ derived after the loop in Line \ref{alg:red:ind-ind-msv:while} in the $i$-th iteration.
For any $\{ d_i \}_{i=1}^t, d_i > 0$,
\begin{align*}
\Pr \left[ \bigwedge_{i=1}^t \mathbf{X}^{(0)} {\mathbf{Y}^{(0)}_i}^T = d_i^2 \right] 
&= \Pr \left[ \mathcal{D}_{\mathcal{B}^{(0)}}(t) = (d_1, \cdots, d_t) \right] \\
&= \Pr \left[ \mathcal{D}_{\mathcal{B}^{(1)}}(t) = (d_1, \cdots, d_t) \right] = \Pr \left[ \bigwedge_{i=1}^t \mathbf{X}^{(1)} {\mathbf{Y}^{(1)}_i}^T = d_i^2 \right]
\end{align*}

Hence, for any $\mathbf{x}$ and $\{ \mathbf{y}_i \}_{i=1}^t$,
\begin{align*}
	& \Pr [\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^\prime_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^\prime_t = \mathbf{y}_t] \\
	&= \sum_{d_1, \cdots, d_t} \Pr \left[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t \mid \bigwedge_{i=1}^t \mathbf{X}^{(1)} {\mathbf{Y}^{(1)}_i}^T = d_i^2 \right] \\
	&\quad \times \Pr \left[\bigwedge_{i=1}^t \mathbf{X}^{(0)} {\mathbf{Y}_i^{(0)}}^T = d_i^2 \right] \\
	&= \sum_{d_1, \cdots, d_t} \Pr \left[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t \mid \bigwedge_{i=1}^t \mathbf{X}^{(1)} {\mathbf{Y}^{(1)}_i}^T = d_i^2 \right] \\
	&\quad \times \Pr \left[\bigwedge_{i=1}^t \mathbf{X}^{(1)} {\mathbf{Y}_i^{(1)}}^T = d_i^2 \right] = \Pr[\mathbf{X}^{(1)} = \mathbf{x}, \mathbf{Y}^{(1)}_1 = \mathbf{y}_1, \cdots, \mathbf{Y}^{(1)}_t = \mathbf{y}_t ]
\end{align*}

\noindent which implies $\mathcal{R}$ also perfectly simulate an \textsf{IND-MSV} game for A when the challenge bit $b = 1$.

In conclusion, 
\[
	\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \Adv_{\Pi, \mathbb{B}, \mathcal{A}}^\textsf{IND-MSV} = \negl.
\]
which holds for all adversaries $\mathcal{A}$ in the \textsf{IND-MSV} game. This implies the IND-MSV security of $\Pi$.


\end{proof}


%-------------------


\section{Security Analysis: Relational Hash-based Instantiation}
\label{sec:security_analysis:rh}

Let $\Pi$ be an authentication scheme instantiated by a relational hash scheme \textsf{RH} as in Section \ref{sec:rh-instantiation}. We discuss the UF and IND-MSV security of $\Pi$ in this section. Note that in this instantiation, $\textsf{esk}, \textsf{psk}, \textsf{csk}$ are all public hash keys $\textsf{pk}$ of \textsf{FE} and assumed to be given to all adversaries.

Given a relational scheme \textsf{RH} for a relation $R \subseteq X \times Y$, we first define the unforgeability \cite{cryptoeprint:2014/394} of \textsf{RH}.

\begin{definition}[Unforgeability]

A relational hash scheme \textsf{RH} is called \emph{unforgeable} for the distribution $\mathcal{X}$ if for any adversary $\mathcal{A}$, the following probability is negligible.
\[
	\Pr \left [
		\begin{aligned} 
			 &\; \mathbf{x} \getsdollar \mathcal{X} \\
			 &\; \textsf{pk} \gets \textsf{RH.KeyGen}(1^\lambda) \\
			 &\; \mathbf{h_x} \gets \textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x})
		\end{aligned} :
		\mathbf{\tilde{z}} \gets \mathcal{A}(\textsf{pk}, \mathbf{h_x}) \wedge \textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{\tilde{z}}) = 1
		\right ] = \negl.
\]

\end{definition}

%Note that in \cite{cryptoeprint:2014/394}, the authors proposed an unforgeable relational scheme for the Hamming distance proximity relation $R^\tau$ for any $\tau < k$.

%-------------------

\subsection{UF Security}
\label{sec:security_analysis:rh:uf}

We first consider $\textsf{option}$ that includes $\mathbf{c_x}$.


\begin{theorem}
\label{thm:rh:uf-uf-cx}

Let $\textsf{option} = \{\mathbf{c_x}, \textsf{esk}, \textsf{psk}, \textsf{csk}\}$. If \textsf{RH} is unforgeable for the distribution
\[
	\mathcal{X} = \{ \mathcal{B} \getsdollar \mathbb{B}: \mathbf{b} \getsdollar \mathbb{B} \mid \mathbb{B} \}
\]
, then $\Pi$ is $\textsf{option}$-unforgeable. 

\end{theorem}

In \cite{cryptoeprint:2014/394}, the authors construct an $\textsf{RH}$ that is unforgeable for the uniform distribution over $\{0, 1\}^k$, under the hardness of some computational problem. Note that we need to provide knowledge of $\mathbb{B}$ in the distribution $\mathcal{X}$.

\begin{proof}

Recall that the distribution of $\mathbf{c_x}$ in the \textsf{UF} game in the instantiation of Section \ref{sec:rh-instantiation} is
\[
	\left \{
		\begin{aligned} 
			 & \mathcal{B} \getsdollar \mathbb{B} \\
			 & \textsf{pk} \gets \textsf{RH.KeyGen}(1^\lambda) \\
			 & \mathbf{x} = \mathbf{b} \getsdollar \mathcal{B} 
		\end{aligned} :
		\mathbf{c_x} \gets \textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x})
	\right \}
\]
Also recall that $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )) = \textsf{RH.Verify}(\textsf{pk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$.
The \textsf{option}-UF security is thus guaranteed by the unforgeability of \textsf{RH}.

\end{proof}

\paragraph{Remark}
As we mentioned in Section \ref{sec:choice-of-option}, an adversary with \textsf{psk} can enjoy a winning rate of the false positive rate \textsf{FP} of $\mathbb{B}$. Theorem \ref{thm:rh:uf-uf-cx} thus implies that if $\textsf{FP}$ is not negligible, there does not exist an \textsf{RH} that is unforgeable for the distribution $\{ \mathcal{B} \getsdollar \mathbb{B}: \mathbf{b} \getsdollar \mathbb{B} \mid \mathbb{B} \}$.


Note that since $\textsf{esk}, \textsf{psk}$, and $ \textsf{csk}$ are all public in this instantiation, it is meaningless to discuss $\mathcal{O}_\textsf{Enroll}, \mathcal{O}_\textsf{Probe}$, or $\mathcal{O}_\textsf{log}^Q$. In addition, for $\textsf{option}$ that includes $\mathcal{O}_\mathcal{B}$ or $\mathcal{O}_\textsf{Probe}^\prime$, as discussed in Section \ref{sec:choice-of-option}, we cannot achieve \textsf{option}-UF security since $\textsf{psk}$ is public in this instantiation.

For \textsf{option} that includes $\mathcal{O}_\textsf{Enroll}^\prime$, we notice that for the \textsf{RH} construction in \cite{cryptoeprint:2014/394}, there exists an invalid $\textsf{pk}^\prime$ such that $\textsf{RH.Hash}_1(\textsf{pk}^\prime, \mathbf{x})$ directly leaks $\mathbf{x}$. By returning $\textsf{RH.Hash}_2( \textsf{pk}, \mathbf{x} )$, one can break the $\textsf{UF}_{\textsf{option}}$ game with probability $1$.


%-------------------

\subsection{IND-MSV Security}
\label{sec:security_analysis:rh:IND-MSV}

\begin{theorem}

For any distribution family $\mathbb{B}$ that $\textsf{TP} - \textsf{FP} > \frac{1}{\poly}$, and for any relational hash scheme \textsf{RH}, $\Pi$ is not IND-MSV secure for any $t \geq 0$.

\end{theorem}

\begin{proof}

Consider the adversary $\mathcal{A}$ in Algorithm \ref{alg:rh:ind}. When the challenge bit $b = 0$, the probability that $\mathcal{A}$ wins is $\textsf{TP}$. When the challenge bit $b = 1$, the probability that $\mathcal{A}$ wins is $1 - \textsf{FP}$. Now, 

\[
	\Adv_{\Pi, \mathbb{B}, \mathcal{A}}^{\textsf{IND-MSV}} = \left| \Pr[ \textsf{IND-MSV}_\Pi(\mathcal{A}) \to 1 ] - \frac{1}{2} \right| = \left| \frac{1}{2} (\textsf{TP} + 1 - \textsf{FP}) - \frac{1}{2} \right| > \frac{1}{\poly}.
\]

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.7\textwidth}
	\begin{algorithm}[H]
	\caption{$\mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}} ( \textsf{csk} = \textsf{pk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$}
	\label{alg:rh:ind}
	\begin{algorithmic}[1]

		\State $\mathbf{y}^{(0)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$
		
		\State $\mathbf{h_y}^{(0)} \gets \textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}^{(0)})$
		
		\If{ $\textsf{RH.Verify}(\textsf{pk}, \mathbf{c_x}, \mathbf{h_y}^{(0)}) = 1$}
		
			\State \Return $0$
		
		\Else
			
			\State \Return $1$
		
		\EndIf
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

\end{proof}

We note that this insecurity result holds whenever $\textsf{psk}$ is public. When $\textsf{esk}$ is public, one can also use $\mathbf{c_y}^{(i)}$ to verify from which distribution the chalenge ciphertexts are generated. We write this observation formally in the following theorem.

\begin{theorem}

Given any distribution family $\mathbb{B}$ that $\textsf{TP} - \textsf{FP} > \frac{1}{\poly}$. If $\textsf{psk}$ is public, $\Pi$ is not IND-MSV secure for any $t \geq 0$. If $\textsf{esk}$ is public, $\Pi$ is not IND-MSV secure for any $t \geq 1$.

\end{theorem}



%-------------------

\newpage

\section{Rough Ideas}

Define the $\textsf{RUF}^\mathcal{O}$ game in Algorithm \ref{alg:oracle-ruf-fh-IPFE} for a real number $\gamma$.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:oracle-ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k}$ \label{alg:oracle-ruf-fh-IPFE:r}

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}} ( \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

The oracle $\mathcal{O}$ can be nothing or includes the following options based on the threat model.

\begin{itemize}

	\item $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$: On input $\mathbf{x}^\prime$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^\prime)$.
	
	\item $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$: On input $\mathbf{y}^\prime$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^\prime)$. The adversary is required to return $\mathbf{\tilde{z}}$ that is not equal to any output of this oracle.
\end{itemize}


\begin{definition}[RUF Security]

	An fh-IPFE scheme \textsf{FE} is called $\mathcal{O}$-RUF secure for a real number $\gamma$ if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the \textsf{RUF} game in Algorithm \ref{alg:ruf-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \mathcal{O}, \gamma} := \Pr[\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\end{definition}

\begin{theorem}[Theorem \ref{thm:ind-uf-OB-Enroll}]
	Let $\textsf{option} = \{ \mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{theorem}[Theorem \ref{thm:ind-uf-OB-Probe}]
	Let $\textsf{option} = \{\mathbf{c_x}, \textsf{csk}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$-RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}




\begin{assumption}
\label{assump}
Let $\mathbf{x} \in \mathbb{F}^k, \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$. Assume that $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z})$ only returns when $\mathbf{z}$ corresponds to a \emph{nonzero} vector $\mathbf{v} \in \mathbb{F}^k$. That is, assume that for any $\mathbf{z}$, there can only be two possibilities.

\begin{itemize}
	\item There exists a vector $\mathbf{v} \in \mathbb{F}^k \setminus \{\mathbf{0}\}$ such that for any $\mathbf{x} \in \mathbb{F}^k, \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, and $\mathbf{c_v} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{v})$, 
	\[
		\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c_v}).
	\]
	\item For any $\mathbf{x} \in \mathbb{F}^k$ and $ \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) \to \bot$.

\end{itemize}
Note that this implies $\textsf{FE}$ rejects zero vector $\mathbf{0}$ as the input of $\textsf{FE.Enc}$.
\end{assumption}


\begin{theorem}
\label{thm:ind-ruf}
Given Assumption \ref{assump}. If \textsf{FE} is fh-IND secure, then $\textsf{FE}$ is $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF secure for any $\gamma \leq \|\mathbb{F}\|$

\end{theorem}

\begin{proof}
Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}$ game for any $\gamma < \|\mathbb{F}\|$. Let $t$ be an integer, consider the reduction adversary $\mathcal{R}$. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ by $\mathcal{O}_\textsf{KeyGen}(\mathbf{x}^\prime, \mathbf{x}^\prime)$.
If there exists an $s_i \neq \bot$ in Line \ref{alg:red:ind-ruf:s}, by Assumption \ref{assump}, let $\mathbf{\tilde{z}}$ correspond to a vector $\mathbf{\tilde{v}}$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-ruf}
	\begin{algorithmic}[1]
		\State $\mathbf{r}^{(0)}, \mathbf{r}^{(1)} \getsdollar \mathbb{F}^{k}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}^{(1)})$ 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{KeyGen}}} (\textsf{pp}, \mathbf{c})$

		\For{$i = 1$ to $t$}
		
			\State $\mathbf{r}_i \getsdollar \mathbb{F}^{k}$

			\State $\mathbf{c}_i \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}_i)$

			\State $s_i \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}_i, \mathbf{\tilde{z}} )$ \label{alg:red:ind-ruf:s}
	
		\EndFor	
		
		\If{$\bigwedge_{i=1}^t s_i \leq \gamma$} \label{alg:red:ind-ruf:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}


If the challenge bit $b = 0$, then by Assumption \ref{assump}, any $s_i \neq \bot$ in Line \ref{alg:red:ind-ruf:s} implies all $s_i \neq \bot$ and $s_i = s_j$ for any $i, j$. Therefore, the probability that all $s_i \leq \gamma$ in Line \ref{alg:red:ind-ruf:verify} is
\begin{align*}
	\Pr\left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right]
	&= \Pr\left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ s_1 \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[ s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \mathbf{r}^{(0)} \mathbf{\tilde{v}}^T \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \leq \gamma \mid b = 0 \wedge s_1 \neq \bot \right] \\
	&= \Pr \left[s_1 \neq \bot \mid b = 0 \right] \cdot \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \mid b = 0 \wedge s_1 \neq \bot \right] \\ 
	&= \Pr \left[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1 \right] 
\end{align*}

If the challenge bit $b = 1$, for any $i \in [t]$,
\begin{align*}
	\Pr[ s_i \leq \gamma \mid b = 1 ]
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ s_i \leq \gamma \mid b = 1 \wedge s_i \neq \bot] \\
	&= \Pr[s_i \neq \bot \mid b = 1] \cdot \Pr[ \mathbf{r}_i \mathbf{\tilde{v}}^T \leq \gamma \mid b = 1 \wedge s \neq \bot]
\end{align*}
Note that $\mathbf{r}_i$ is independent of $\mathbf{\tilde{z}}$ and thus independent of $\mathbf{\tilde{v}}$. Hence, $\Pr[\mathbf{r}_i \mathbf{\tilde{v}}^T \leq \gamma \mid b = 1 \wedge s_i \neq \bot] = \frac{\gamma}{\| \mathbb{F} \|}$ and
\[
	\Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] = \Pr \left[ \bigwedge_{i=1}^t s_i \neq \bot \mid b = 1 \right] \cdot \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \leq \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t
\]

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 0 \right] - \Pr \left[ \bigwedge_{i=1}^t s_i \leq \gamma \mid b = 1 \right] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] - \left( \frac{\gamma}{\| \mathbb{F} \|} \right)^t \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] -  e^{- t \cdot (1 - \frac{\gamma}{\| \mathbb{F} \|}) } \right)
\end{align*}

\noindent Take $t$ be any integer larger than $\frac{\lambda}{ 1 - \frac{\gamma}{\| \mathbb{F} \| }}$. Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $e^{-t \cdot (1 - \frac{\gamma}{\| \mathbb{F} \|}) } \leq e^{-\lambda}$ are negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \leq e^{- t \cdot (1 - \frac{\gamma}{\| \mathbb{F} \|}) } + 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND}  = \negl.
\]

\end{proof}
\newpage


\section{Agenda}

\begin{enumerate}

\item Current $\textsf{UF}^\prime$ game (Algorithm \ref{alg:plain-uf_game}) exist trivial attacks by returning $\mathbf{0}$ vector. Possible workarounds:

\begin{enumerate}
	\item Let the adversary return $i$, and then use $\mathbf{y} \gets \textsf{encodeProbe}^{\mathcal{O}_\textsf{samp}(i)}()$.

	\item Remove $\textsf{UF}^\prime$ and replace $\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1]  $ with $q \cdot \textsf{FP}$.

	\item Do nothing. Let it be a problem of the inner-product functional encryption instantiation.

	\item \textbf{(Final) Redefine $\textsf{UF}^\prime$ to encode the output of the adversary.}

\end{enumerate}

\item When $\textsf{UF}$ adversary has both $\mathcal{O}_\mathcal{B}$ and $\mathcal{O}_\textsf{Probe}$, I think we should not consider baseline security $\textsf{UF}^\prime$ in advantage since the adversary cannot return what $\mathcal{O}_\textsf{Probe}$ gives it.

\item If an fh-IPFE scheme \textsf{FE} is fh-IND secure, by our current definition, sampling a $\mathbf{c_v}$ that corresponds to $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{v})$ of a random $\mathbf{v}$ and $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_v})$ always returns is \emph{impossible}. However, it is \emph{possible} \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440} if we allow decryption to return $\bot$ on most $\mathbf{x}, \mathbf{y} \in \mathbb{F}^k$.
\item I looked at some fh-IPFE constructions.

\begin{enumerate}

	\item In \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24, cryptoeprint:2016/440}
	\begin{itemize}
		\item The field size $|\mathbb{F}| = |\Z_q| = q$ is of exponential size of $\lambda$.
		\item The decryption relies on finding $\langle \mathbf{x}, \mathbf{y} \rangle$ from $g^{\langle \mathbf{x}, \mathbf{y} \rangle}$ for a group generator $g$ of order $q$. Discrete logarithm is hard. $\textsf{FE.Dec}$ works only when $\langle \mathbf{x}, \mathbf{y} \rangle$ ranges in a pre-defined polynomial-size set.
		\item \cite{cryptoeprint:2015/1255, 10.1007/978-3-319-45871-7_24} are fh-IND secure. \cite{cryptoeprint:2016/440} is fh-IND secure in the generic group model.
		\item One can sample a random ciphertext $\mathbf{c_v}$, but then it is difficult to find any $\mathbf{c_x}$ such that $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_v}) \neq \bot$. 
		\item \cite{cryptoeprint:2015/1255, cryptoeprint:2016/440} are $\mathcal{O}_\textsf{KeyGen}^\prime$-RUF secure by Theorem \ref{thm:ind-ruf}.
	\end{itemize}

	\item In \cite{cryptoeprint:2018/1214, 10.1007/978-3-030-90567-5_33}:
	\begin{itemize}
		\item The field size $|\mathbb{F}| = |\Z_q| = q$ is polynomial of $\lambda$
		\item They prove security in a game that only allows the adversary to call $\mathcal{O}_\textsf{KeyGen}$ once, and it must be before $\mathcal{O}_\textsf{Enc}$.
		\item They are not fh-IND secure.
		\item They are also not RUF secure because one can sample random ciphertext $\mathbf{c_v}$.
	\end{itemize}
\end{enumerate}

\item In general, I think RUF security cannot be easliy proven without adding a signature.

\end{enumerate}






%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\nocite{*}
\printbibliography


\end{document}
