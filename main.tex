%%%%%%%%%%%%%%%%%%%%

% Semester Project Fall 2024 for EPFL
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Semester Project}
\fancyhead[C]{Biometric Authentication}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------

This report formalizes the biometric authentication scheme, including its structure, usage, and security analysis with a security game model.

%-------------------

\section{Preliminaries}
\label{sec:preliminaries}

In this report, we assume

\begin{itemize}
	
	\item $\lambda$ is the security parameter.

	\item $[m]$ denotes the set of integers $\{1, 2, \cdots, m\}$.

	\item $\Z_q$ is the finite field modulo a prime number $q$.

	\item A function $f(n)$ is called \emph{negligible} iff for any integer $c$, $f(n) < \frac{1}{n^c}$ for all sufficiently large $n$. We write it as $f(n) = \negl$, and we may also use $\negl$ to represent an arbitrary negligible function.
	
	\item $\poly$ is the class of polynomial funcions. We may also use $\poly$ to represent an arbitrary polynomial function.
	
	\item We write sampling a value $r$ from a distribution $\mathcal{D}$ as $r \getsdollar \mathcal{D}$. If $S$ is a finite set, then $r \getsdollar S$ means sampling $r$ uniformly from $S$.

	\item The distribution $\mathcal{D}^t$ denotes $t$ identical and independent distributions of $\mathcal{D}$.

	\item A PPT algorithm denotes a probabilistic polynomial time algorithm. Unless otherwise specified, all algorithms run in PPT.

\end{itemize}

We introduce three types of inner product functional encryption schemes: function hiding functional encryption, two-input functional encryption, and two-client functional encryption. We will instantiate our biometric authentication scheme using these primitives.

\begin{definition}[Function Hiding Inner Product Functional Encryption]
\label{def:fh-IPFE}
	A \emph{function hiding inner product functional encryption} (fh-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$: It outputs the public parameter $\textsf{pp}$ and the master secret key $\textsf{msk}$.
	
		\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$: It generates the functional decryption key $f_\mathbf{x}$ for an input vector $\mathbf{x} \in \mathbb{F}^k$. 
	
		\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$: It encrypts the input vector $\mathbf{y} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_y}$. 
	
		\item $\textsf{FE.Dec}(\textsf{pp}, f_\mathbf{x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The fh-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$ and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}( \textsf{pp}, \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}), \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) ) = \mathbf{x} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using an fh-IPFE scheme is given in Section \ref{sec:fh-IPFE-instantiation}.

\begin{definition}[Two-Input Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2i-IPFE}
	A \emph{two-input inner product functional encryption} (2i-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2i-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, and $\mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have

	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2i-IPFE is given in Section \ref{sec:2i-IPFE-instantiation}.

\begin{definition}[Two-Client Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2c-IPFE}
	A \emph{two-client inner product functional encryption} (2c-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\ell, \textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given a label $\ell$ and an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2c-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, label $\ell$, and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2c-IPFE is given in Section \ref{sec:2c-IPFE-instantiation}.

We also consider an instantiation using a relational hash scheme.

\begin{definition}[Relational Hash (adapted from \cite{cryptoeprint:2014/394})]
\label{def:rh}
	Let $R_\lambda$ be a relation over sets $X_\lambda, Y_\lambda$, and $ Z_\lambda$. A \emph{relational hash} scheme \textsf{RH} for $R_\lambda$ consists of PPT algorithms \textsf{RH.KeyGen}, $\textsf{RH.HASH}_1$, $\textsf{RH.HASH}_2$, and \textsf{RH.Verify}:
	
	\begin{itemize}
	
		\item $\textsf{RH.KeyGen}(1^\lambda) \to \textsf{pk}$: It outputs a public hash key \textsf{pk}.  
			
		\item $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$: Given a hash key \textsf{pk} and $\mathbf{x} \in X_\lambda$, it outputs a hash $\mathbf{h_x}$.

		\item $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$: Given a hash key \textsf{pk} and $\mathbf{y} \in Y_\lambda$, it outputs a hash $\mathbf{h_y}$.

		\item $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}) \to r \in \{0, 1\}$: Given a hash key \textsf{pk}, two hashes $\mathbf{h_x}$ and $\mathbf{h_y}$, and $\mathbf{z} \in Z_\lambda$, it verifies whether the relation among $\mathbf{x}, \mathbf{y}$ and $\mathbf{z}$ holds.

	\end{itemize}

	\noindent Correctness: The relational hash scheme \textsf{RH} is \emph{correct} if $\forall \mathbf{x}, \mathbf{y}, \mathbf{z} \in X_\lambda \times Y_\lambda \times Z_\lambda$,
	\[
		\Pr \left [
			\begin{cases} 
				 \textsf{pk} \gets \textsf{RH.KeyGen}(1^\lambda) \\
				 \mathbf{h_x} \gets \textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \\
				 \mathbf{h_y} \gets \textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y})
			\end{cases} :
			\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}, \mathbf{z}) = R(\mathbf{x}, \mathbf{y}, \mathbf{z})
			\right ] = 1 - \negl.
	\]
\end{definition}

Instantiation using a relational hash is given in Section \ref{sec:rh-instantiation}.


%-------------------


\section{Formalization}
\label{sec:formalization}


In general, an authentication shceme $\Pi$ associated with a family of biometric distributions $\mathbb{B}$ is composed of the following algorithms.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda) \to \textsf{esk}, \textsf{psk}, \textsf{csk}$: It outputs the enrollment secret key $\textsf{esk}$, probe secret key $\textsf{psk}$, and compare secret key $\sf csk$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{x}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{x}$, the input format for enrollment. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x}) \to \mathbf{c_x}$: It outputs the enrollment message $\mathbf{c_x}$ from $\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{y}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{y}$, the input format for probe.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y}) \to \mathbf{c_y}$: It outputs the probe message $\mathbf{c_y}$ from $\mathbf{y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)} \to s$: It compares the enrollment message $\mathbf{c_x}$ and probe message $\mathbf{c_y}$ and outputs a score $s$.

	\item $\textsf{Verify}(s) \to r \in \{0,1\}$: It is a deterministic algorithm that reads the comparison score $s$ and determines whether this is a successful authentication ($r = 1$) or not ($r = 0$).

\end{itemize}

\noindent 
We discuss two usage models that employs the authentication scheme $\Pi$.


%-------------------


\subsection{Usage Model – Device-of-User}
\label{sec:dou_model}

In the model described in Figure \ref{fig:model_dou_overview} (an overview), Figure \ref{fig:model_dou_enrollment} (on enrollment), and Figure \ref{fig:model_dou_auth} (on authentication), users authenticate themselves to a server through their own devices and biometric scanners that are shared among different users.
A key distribution service distributes keys for them. In practice, this model applies to the situation when the users access an online service run by the server.

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$. 

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Device}: A device belonging to the user. In practice, it can be a desktop or a mobile phone. It processes the \textsf{Enroll} and \textsf{Probe} functions for $\textsf{User}$ with keys \textsf{esk} and \textsf{psk}. It queries $\mathcal{O}_{\mathcal{B}}$ for biometric data through the \textsf{Scanner}.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to $\textsf{Device}$ and $\textsf{Server}$.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}

The Device-of-User model, when instantiated by an fh-IPFE scheme (Section \ref{sec:fh-IPFE-instantiation}), is analogous to the use case presented in \cite{cryptoeprint:2023/481}.
In their model, a user possesses a personal device, such as a smartphone or laptop, and a secure hardware device that runs an initial setup and stores all the keys, which corresponds to our \textsf{KDS}.
On enrollemnt and authentication, the user inputs biometric templates onto the device, which corresponds to our \textsf{Scanner}.
Subsequently, the device transmits the template to the secure hardware for the enrollment or probing processes, which are equivalent to our \textsf{Device}.
In addition, they incorporate a two-factor authentication mechanism.
The secure hardware also executes a digital signature scheme and sign the probe message on authentication.


\input{tikz/dou_model.tex}

%-------------------

\subsection{Usage Model – Device-of-Domain}
\label{sec:dod_model}

In the model described in Figure \ref{fig:model_dod_overview} (an overview), Figure \ref{fig:model_dod_enrollment} (on enrollment), and Figure \ref{fig:model_dod_auth} (on authentication), users first enroll themselves at an enrollment station and then authenticate themselves to a server through devices that belong to a domain.
A key distribution service distributes enrollment keys to the enrollment station, probe keys to the domain, and comparison keys to the server. In practice, a domain can be a department in an organization, and this models applies to the situation when a user wants to access a public service of a department, such as a restricted area or instruments. 

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data at an enrollment station and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$.
	
	\item \textsf{Domain}: A domain that owns several devices, all of which share one enrollment key $\textsf{esk}$, one probe key $\textsf{psk}$ and one comparison key $\textsf{csk}$. Only the probe key is stored at each device of a domain. The enrollment key is stored at the enrollment station, and the comparison key is stored at the server. In practice, a domain can be a department, and users enroll and authenticate themselves before accessing a restricted service of this department.

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Station}: An enrollment station responsible for collecting the user's biometric data to enroll them for a domain on the server.

	\item \textsf{Device}: A device belonging to a domain. In practice, it can be a device checking identities for a restricted area or an instrument. It owns a probe key $\sf psk$ and processes the $\sf Probe$ function for enrolled users of this domain.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to \textsf{Station}, \textsf{Domain}, and \textsf{Server}.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} for each domain and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}


%-------------------

\input{tikz/dod_model.tex}

\pagebreak

%-------------------

\subsection{Instantiation with an fh-IPFE Scheme}
\label{sec:fh-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be an fh-IPFE scheme we defined in Definition \ref{def:fh-IPFE}. Following \cite{cryptoeprint:2023/481}, we can instantiate a biometric authentication scheme using $\textsf{FE}$ with the distance metric the Euclidean distance. Let the biometric distribution $\mathcal{B} \subseteq [m]^k$, and let the associated field of $\textsf{FE}$ be $\mathbb{Z}_q$ where $q$ is a prime number larger than the maximum possible Euclidean distance $m^2 \cdot k$. The scheme is instantiated as follows.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$ and outputs $\textsf{esk} \gets (\textsf{msk}, \textsf{pp})$, $\textsf{psk} \gets (\textsf{msk}, \textsf{pp})$ and $\textsf{csk} \gets \textsf{pp}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b} = (b_1, b_2, \cdots, b_k)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{x} = (x_1, x_2, \cdots, x_{k+2}) = (b_1, b_2, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$ and outputs $\mathbf{c_x} \gets f_\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime = (b_1^\prime, b_2^\prime, \cdots, b_k^\prime)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{y} = (y_1, y_2, \cdots, y_{k+2}) = (-2b_1^\prime, -2b_2^\prime, \cdots, -2b_k^\prime, \|\mathbf{b}^\prime\|^2, 1)$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{y}^T = \sum_{i=1}^k -2b_ib_i^\prime + \|\mathbf{b}\|^2 + \|\mathbf{b}^\prime\|^2 = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]

which is the square of the Euclidean distance between two templates $\mathbf{b}$ and $\mathbf{b}^\prime$. Therefore, if two templates $\mathbf{b}$ and $\mathbf{b}^\prime$ are close enough such that $\|\mathbf{b} - \mathbf{b}^\prime\| \leq \tau$, the scheme results in $r = 1$, a successful authentication.


Instantiated with an fh-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is public, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are the same. Anyone with access to the enrollment message $\mathbf{c_x}$ and either one of $\textsf{esk}$, $\textsf{psk}$, or a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot )$ can probe some $\mathbf{y}^{\prime} \in \mathbf{F}^{k+2}$ and find $\mathbf{x} {\mathbf{y}^\prime}^T$ to get partial or full information about $\mathbf{x}$. Even if the adversary can only sample random ciphertexts $\mathbf{c_{y}}$ without knowing $\mathbf{y}$, if the field size $q$ is not large enough, one can find a forged $\mathbf{c_{y^*}}$ such that $\mathbf{x}\mathbf{y^*}^T \leq \tau$ to impersonate the user by sampling many times offline.


Therefore, \textsf{Server} must store $\mathbf{c_x}$ securely, to avoid such an attack from an adversary who can access the probe oracle; \textsf{Device} must protect its probe function, to avoid such an attack from a malicious \textsf{Server}. 

In the Device-of-Domain model, we assume the probe oracle is public, just as everyone can try accessing a public service. A malicious \textsf{Station} or \textsf{Server}, who has the enrollment message $\mathbf{c_x}$, can utilize this attack to retrieve information about \textsf{User}.


%-------------------


\subsection{Instantiation with a 2i-IPFE Scheme}
\label{sec:2i-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2i-IPFE scheme we defined in Definition \ref{def:2i-IPFE}. Following the scheme in Section \ref{sec:fh-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $ \textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. It outputs $\textsf{esk} \gets \textsf{ek}_1$, $\textsf{psk} \gets \textsf{ek}_2$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:fh-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \mathbf{x} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:fh-IPFE-instantiation}


Unlike the previous scheme, instantiated with a 2i-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is now secret, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are distinct. Without $\textsf{csk}$, one cannot compare an enrollment message $\mathbf{c_x}$ and a probe message $\mathbf{c_y}$. We can also transmit $\mathbf{c_x}$ in a public channel and store it in a public storage, under necessary security requirements of the 2i-IPFE scheme, such as indistinguishability of $\mathbf{c_x}$.

In the Device-of-Domain model, the indistinguishability of $\mathbf{c_x}$ is against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$. If \textsf{Server} is malicious, then it can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ enrolled by different samples. Therefore, we must limit the adversary's ability. For example, we can require the adversary to distinguish biometric vectors sampled from distributions in a pre-defined pool, and the adversary can only probe vectors randomly sampled from a distribution in the pool. We can also limit the rate of the probe oracle.

%-------------------

\subsection{Instantiation with a 2c-IPFE Scheme}
\label{sec:2c-IPFE-instantiation}

Note that if labels remain constant, a 2c-IPFE scheme is reduced to a 2i-IPFE scheme. Therefore, we can consider utilizing the label to represent each domain in the Device-of-Domain model. Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2c-IPFE scheme we defined in Definition \ref{def:2c-IPFE}. Following the scheme in Section \ref{sec:2i-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $\textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. For keys used for \textsf{Domain} $\ell$, it outputs $\textsf{esk} \gets (\ell, \textsf{ek}_1)$, $\textsf{psk} \gets (\ell, \textsf{ek}_2)$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$.

	Note that when the previous 2i-IPFE-based scheme in Section \ref{sec:2i-IPFE-instantiation} is applied to a Device-of-Domain model, we assume that $\textsf{Setup}$ is run once for each domain to generate different $\textsf{esk}, \textsf{psk}, \textsf{csk}$. In the scheme in this section, however, $\textsf{Setup}$ is run only once for all the domains, and each domain shares the same $\textsf{csk}$ and the same $\textsf{esk}, \textsf{psk}$ except different labels.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:2i-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} \leq \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, if the labels of $\mathbf{c_x}$ and $\mathbf{c_y}$ are the same (they are of the same domain), we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:2i-IPFE-instantiation}

When the Device-of-Domain model is instantiated with a 2c-IPFE scheme in this way, the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are now shared among all the devices, regardless of their domains. Therefore, to let a malicious or broken \textsf{Domain} not threaten other honest ones, one needs to make sure given $\textsf{esk}$ or $\textsf{psk}$, $\mathbf{c_x}$ still does not leak information about $\mathbf{x}$. This is different from the scheme in Section \ref{sec:2i-IPFE-instantiation}, where we only need seurity against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$.

If \textsf{Server} and \textsf{Domain} are both malicious, then the adversary can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ and even recover $\mathbf{x}$. Therefore, we assume at most one party of them can be malicious at the same time. Note that this is the same as the 2i-IPFE-based scheme, where only one of \textsf{Server} and \textsf{Domain} can be malicious.

%-------------------

\subsection{Instantiation with a Relational Hash Scheme}
\label{sec:rh-instantiation}

Let $\textsf{RH} = (\textsf{RH.KeyGen}, \textsf{RH.Hash}_1, \textsf{RH.Hash}_2, \textsf{RH.Verify})$ be a relational hash scheme we defined in Definition \ref{def:rh} for the relation $R$ of Hamming distance proximity parametrized by a constant $\tau$.
\[
	R = \{ (\mathbf{x}, \mathbf{y}) \mid \textsf{HD}(\mathbf{x}, \mathbf{y}) \leq \tau \wedge \mathbf{x}, \mathbf{y} \in \{0,1\}^k \}
\]
Note that here we ignore the third parameter $Z$.
Following \cite{cryptoeprint:2023/481} and \cite{cryptoeprint:2014/394}, we can instantiate a biometric authentication scheme using $\textsf{RH}$.  Let the biometric distribution $\mathcal{B} \subseteq \{0,1\}^k$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{RH.Setup}(1^\lambda) \to \textsf{pk}$ and outputs $\textsf{esk} \gets \textsf{pk}$, $\textsf{psk} \gets \textsf{pk}$, and $\textsf{csk} \gets \textsf{pk}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}$ sampled from $\mathcal{O}_\mathcal{B}$, it direclty outputs $\mathbf{x} \gets \mathbf{b}$.

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$ and outputs $\mathbf{c_x} \gets \mathbf{h_x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime$ sampled from $\mathcal{O}_\mathcal{B}$, it directy outputs $\mathbf{y} \gets \mathbf{b}^\prime$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$ and outputs $\mathbf{c_y} \gets \mathbf{h_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: It direclty returns $r \gets s$.

\end{itemize}

By the correctness of the relational hash scheme $\textsf{RH}$, we have (except for a negligible probability),
\[
	r = 1 \Leftrightarrow (\mathbf{x}, \mathbf{y}) \in R \Leftrightarrow \textsf{HD}(\mathbf{b}, \mathbf{b}^\prime) \leq \tau
\]


%-------------------


\section{Security Games}
\label{sec:security_game}

To rigorously analyze the security of an authentication scheme, we simulate biometric distributions of users by assuming the existence of a family $\mathbb{B}$ of distributions. We require that all distributions in $\mathbb{B}$ are efficiently samplable and has an excessively large size for a PPT adversary to enumerate. We then provide interfaces for all algorithms to interact with $\mathbb{B}$.

\begin{itemize}

	\item $\textsf{BioSamp}()$: Generate a random distribution $\mathcal{B}$ of $\mathbb{B}$. By this we mean providing either parameters of an efficiently samplable distribution or a PPT algorithm as the sampler. For simplicity, we write $\mathcal{B} \gets \textsf{BioSamp}()$ as $\mathcal{B} \getsdollar \mathbb{B}$.
	
	\item $\textsf{BioDelete}(\mathcal{B})$: Delete $\mathcal{B}$ from $\mathbb{B}$. Consequently, no further access to $\textsf{BioSamp}$ can derive $\mathcal{B}$. For simplicity, we write $\textsf{BioDelete}(\mathcal{B})$ as $\mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$.

	\item $\mathcal{O}_\textsf{samp}(\cdot)$: On input an index $i$,
	\begin{itemize}
		\item If $i$ was not queried before, it first samples a biometric distribution $\mathcal{B}_i \in \mathbb{B}$ by $\textsf{BioSamp}$ and then outputs a biometric template sampled from the distribution $\mathcal{B}_i$, denoted by $\mathbf{b} \getsdollar \mathcal{B}_i$.
		\item If $i$ has been queried before, it outputs a biometric template sampled from the distribution $\mathcal{B}_i$, denoted by $\mathbf{b} \getsdollar \mathcal{B}_i$.
	\end{itemize}
\end{itemize}

% Comment
\iffalse

In Table \ref{table:security_games}, we list a summary of the adversary in each game.

\begin{table}[htp]
\centering
	\begin{tabular}{l l c l@{\hspace{15pt}} l}
	\toprule

		\multicolumn{2}{c}{ \multirow{2}{*}{\textbf{Games}} } & \multirow{2}{*}{\textbf{Goals}} & \multicolumn{2}{c}{\textbf{Knowledge and Oracles}} \\

		\cmidrule{4-5}
		
		 & & & \makecell[c]{Device-of-User} & \makecell[c]{Device-of-Domain} \\

	\midrule
	
		\textsf{UF-MSC} &(Section \ref{sec:uf-msc_game}) & Forge a probe & $\mathbf{c_x}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{auth}^q$ & $\mathbf{c_x}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]

		\textsf{UF-MDV} &(Section \ref{sec:uf-mdv_game}) & Forge a probe & $\textsf{esk}, \textsf{psk}, \mathbf{c_x},\mathcal{O}_\textsf{auth}^q$ & $\textsf{psk}, \mathbf{c_x},\mathcal{O}_\textsf{auth}^q$ \\ [5pt]

		\textsf{UF-MDM} &(Section \ref{sec:uf-mdm_game}) & Forge a probe & \makecell[c]{-} & $\mathbf{c_x}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_{\textsf{Probe}}^\prime, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]
		
		\textsf{UF-MST} &(Section \ref{sec:uf-mst_game}) & Forge a probe & \makecell[c]{-} & $ \textsf{esk}, \mathbf{c_x}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_{\textsf{Enroll}}^\prime, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]
		
		\textsf{IND-MSV} &(Section \ref{sec:ind-msv_game}) & Identify \textsf{User} 
			& \makecell[l]{ $\textsf{csk}, \mathbf{c_x}, \{\mathbf{c_y}\}_{i=1}^t$, \\ $\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}$ } 
			& \makecell[l]{ $ \textsf{csk}, \mathbf{c_x}, \{\mathbf{c_y}\}_{i=1}^t$, \\ $\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}, \mathcal{O}_{\textsf{Probe}}^{\textsf{samp}} $ } \\

	\bottomrule
	\end{tabular}
	\caption{Summary of Adversaries in Security Games}
	\label{table:security_games}

\end{table}

\fi
%-------------------

\newpage

%-------------------

\subsection{Unforgeability}
\label{sec:uf_game}

To describe the unforgeability of an authentication scheme, we model the ability of an adversary who tries to impersonate \textsf{User}. The adversary $\mathcal{A}$ is given the sampling oracle $\mathcal{O}_\textsf{samp}$ and auxiliary information \textsf{option}, which depends on our threat model. The adversary tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game $\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}$ is defined in Algorithm \ref{alg:uf_game}.

\begin{figure}[h]
\centering
	\begin{minipage}[t]{0.8\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:uf_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$
		
		\For{$i = 1$ to $L$}

			\State $\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i \gets \textsf{Setup}(1^\lambda)$ \Comment{Keys for Domain $i \in [L]$}
		
		\EndFor

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$
		
		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O}_{\textsf{samp}} } ( \textsf{option} )$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:uf_game}
\end{figure}

The auxiliary information \textsf{option} can be nothing or include $\mathbf{c_x}, \textsf{esk}, \textsf{psk}, \textsf{esk}_i, \textsf{psk}_i$ for $i \in [L]$ or the following oracles:

\begin{itemize}

	\item $\mathcal{O}_{\mathcal{B}}$: It outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}$.
	
	\item $\mathcal{O}_\textsf{Enroll}(\textsf{esk}, \cdot)$: On input $\mathbf{x}^\prime$, it outputs the enrollment message $\textsf{Enroll}(\textsf{esk}, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}(\textsf{psk}, \cdot)$: On input $\mathbf{y}^\prime$, it outputs the probe message $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime)$. If this oracle and $\mathcal{O}_{\mathcal{B}}$ are given at the same time, we require the adversary to return some $\mathbf{\tilde{z}}$ that is not equal to any previous answer of $\mathcal{O}_\textsf{Probe}$.
	
	\item $\mathcal{O}_\textsf{log}^{q}(\textsf{csk}, \mathbf{c_x}, \cdot)$: This is a resource-limited oracle. If it has been queried over $q$ times in total, it aborts. Otherwise, on input $\mathbf{z}$, it outputs $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{z} ) )$. We omit $q$ in the superscript when we allow unbounded number of queries. 

	\item $\mathcal{O}_\textsf{auth}^{q}(\textsf{csk}, \cdot, \cdot)$: This is a resource-limited oracle. If it has been queried over $q$ times in total, it aborts. Otherwise, on input $\mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}$, it outputs $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}} ) )$. We omit $q$ in the superscript when we allow unbounded number of queries. 
	
	\item $\mathcal{O}_\textsf{Enroll}^{(i)}(\textsf{esk}_i, \cdot)$: On input $\mathbf{x}^\prime$, it outputs the enrollment message $\textsf{Enroll}(\textsf{esk}_i, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}^{(i)}(\textsf{psk}_i, \cdot)$: On input $\mathbf{y}^\prime$, it outputs the probe message $\textsf{Probe}(\textsf{psk}_i, \mathbf{y}^\prime)$. 
	
	\item $\mathcal{O}_\textsf{Enroll}^\prime (\cdot)$: On input $\textsf{esk}^\prime$, it first samples $\mathbf{x}^\prime \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Enroll}(\textsf{esk}^\prime, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}^\prime (\cdot)$: On input $\textsf{psk}^\prime$, it first samples $\mathbf{y}^\prime \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Probe}(\textsf{psk}^\prime, \mathbf{y}^\prime)$. This oracle and $\textsf{psk}$ should not be given at the same time. 
	
\end{itemize}

If $\textsf{option}$ does not include $\mathcal{O}_\textsf{Probe}$, we define the advantage of an adversary $\mathcal{A}$ with $\textsf{option}$ in the \textsf{UF} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1]
\]

When $\textsf{option}$ includes $\textsf{psk}$ or $\mathcal{O}_\textsf{Probe}$, to consider potential non-negligible false positive rates of biometrics match, we define the plain $\textsf{UF}^\prime$ game in Algorithm \ref{alg:plain-uf_game}, where the adversary has only $\mathcal{O}_\textsf{samp}$ and $\mathcal{O}_\textsf{log}^{q}$ and tries to find a vector $\mathbf{\tilde{z}}$ close to $\mathbf{x}$.

\begin{figure}[H]
\centering
	\begin{minipage}[t]{0.5\linewidth}
	\begin{algorithm}[H]
	\caption{$\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime)$}
	\label{alg:plain-uf_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\prime \mathcal{O}_\textsf{samp}, \mathcal{O}_\textsf{log}^q }()$

		\State $\mathbf{\tilde{c_z}} \gets \textsf{Probe}(\textsf{psk}, \mathbf{\tilde{z}})$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{c_z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
\label{fig:plain-uf_game}
\end{figure}

The advantage of an adversary $\mathcal{A}$ is defined as
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[\textsf{UF}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1].
\]

An authentication scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions is called \emph{\textsf{option}-unforgeable} (\textsf{option}-UF) if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{UF}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} = \negl.
\]

Note that if a \textsf{UF} game adversary can simulate a $\textsf{UF}^\prime$ game and $\textsf{csk}$ is empty or public, the scheme cannot achieve UF security when the false positive rate is not negligible, as the adversary can run $\textsf{Verify}( \textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \cdot) )$ over $q$ times to boost the false positive rates.

For the rest of this report, if the scheme, the family distribution, and the auxiliary information $\textsf{option}$ are clear from context, we omit the subscript and write the game as $\textsf{UF}(\mathcal{A})$. This abbreviation also holds for all other games.


%-------------------


\subsection{Indistinguishable against Malicious Server (IND-MSV)}
\label{sec:ind-msv_game}

In the game of Indistinguishable against Malicious Server, we model the ability of a malicious \textsf{Server} who tries to identify the user. The adversary $\mathcal{A}$ is given oracles to two biometric distributions $\mathcal{B}^{(0)}, \mathcal{B}^{(1)}$, the comparison key $\textsf{csk}$, an enrollment message $\mathbf{c_x}$, and a list of $t$ probe messages $\{ \mathbf{c_y}^{(i)} \}_{i=1}^t$ . It tries to guess from either $\mathcal{B}^{(0)}$ or $ \mathcal{B}^{(1)}$ these messages are generated. The whole game is defined in Algorithm \ref{alg:ind-msv_game}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.6\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{IND-MSV}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:ind-msv_game}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$

		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(b)}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\For{$i = 1$ to $t$}

			\State $\mathbf{y}^{(i)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(b)}}}() $
		
			\State $\mathbf{c_y}^{(i)} \gets \textsf{Probe}( \textsf{psk}, \mathbf{y}^{(i)} )$

		\EndFor

		%\State In Device-of-User Model:
		
			%\State \hspace{\algorithmicindent} $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}} } ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		%\State In Device-of-Domain Model:
		
			\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}} ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

%\caption{The \textsf{IND-MSV} Game}
\label{fig:ind-msv_game}
\end{figure}

%Note that in Device-of-Domain model, a probe oracle is given to the adversary.

%\begin{itemize}

	%\item $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$: On input an index $i$, it first samples $\mathbf{y}^\prime \getsdollar \textsf{encodeProbe}^{\mathcal{O}_{\textsf{samp}}(i)}$, which uses $\mathcal{O}_{\textsf{samp}}(i)$ to answer biometric queries, and outputs $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime )$. 

%\end{itemize}

%We provide $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$ instead of $\mathcal{O}_{\textsf{Probe}}(\textsf{psk}, \cdot)$. This is to avoid the trivial attack where the adversary probes samples from the oracles $\mathcal{O}_{\mathcal{B}^{(0)}}$ and $\mathcal{O}_{\mathcal{B}^{(1)}}$ and compare the results with $\mathbf{c_x}$.

We define the advantage of an adversary $\mathcal{A}$ in the \textsf{IND-MSV} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}^\mathcal{O}} := \left |\Pr[\textsf{IND-MSV}_{\Pi}(\mathcal{A}) \to 1] - \frac{1}{2} \right|.
\]

An authentication scheme $\Pi$ associated with a family $\mathbb{B}$ of distributions is called \emph{indistinguishable against malicious server (IND-MSV)} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}} = \negl.
\]

%-------------------


\section{Security Analysis}
\label{sec:security_analysis}

Given an fh-IPFE scheme \textsf{FE}, we define the \textsf{fh-IND} game in algorithm \ref{alg:ind-fh-IPFE}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.4\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ind-fh-IPFE}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}} ( \textsf{pp} )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ind-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}_{\textsf{KeyGen}}(\cdot, \cdot)$: On input pair $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^{(b)} )$.

	\item $\mathcal{O}_{\textsf{Enc}}(\cdot, \cdot)$: On input pair $(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^{(b)} )$.

\end{itemize}

\noindent To avoid trivial attacks, we consider \emph{admissible adversaries}.

\begin{definition}[Admissible Adversary]

	Let $\mathcal{A}$ be an adversary in an \textsf{fh-IND} game, and let $ (\mathbf{x}_1^{(0)}, \mathbf{x}_1^{(1)}), \cdots, (\mathbf{x}_{Q_K}^{(0)}, \mathbf{x}_{Q_K}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{KeyGen}}$ and $(\mathbf{y}_1^{(0)}, \mathbf{y}_1^{(1)}), \cdots, (\mathbf{y}_{Q_E}^{(0)}, \mathbf{y}_{Q_E}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{Enc}}$.
	We say $\mathcal{A}$ is \emph{admissible} if $\forall i \in [Q_K], \forall j \in [Q_E]$,
\[
	{\mathbf{x}^{(0)}_{i}} {\mathbf{y}^{(0)}_{j}}^T = {\mathbf{x}^{(1)}_{i}} {\mathbf{y}^{(1)}_{j}}^T
\]

\end{definition}


\begin{definition}[fh-IND Security]

	An fh-IPFE scheme \textsf{FE} is called fh-IND secure if for any admissible adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the $\textsf{fh-IND}$ game in Algorithm \ref{alg:ind-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{fh-IND}} := \left| \Pr[\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A}) \to 1 ] - \frac{1}{2} \right| = \negl.
\]

\end{definition}


We also define the \textsf{RUF} game in algorithm \ref{alg:ruf-fh-IPFE} for a real number $\gamma$.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$ \label{alg:ruf-fh-IPFE:r}

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} } ( \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ruf-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$: On input $\mathbf{x}^\prime$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^\prime)$.
	
	\item $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$: On input $\mathbf{y}^\prime$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^\prime)$. The adversary is required to return $\mathbf{\tilde{z}}$ that is not equal to any output of this oracle.
\end{itemize}


\begin{definition}[RUF Security]

	An fh-IPFE scheme \textsf{FE} is called RUF secure for a real number $\gamma$ if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the \textsf{RUF} game in Algorithm \ref{alg:ruf-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} := \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\end{definition}


%-------------------


\subsection{fh-IND Security and UF Security}
\label{sec:ind-uf-lob}

Let $\Pi$ be the authentication scheme instantiated by an fh-IPFE scheme \textsf{FE} as in Section \ref{sec:fh-IPFE-instantiation}.


\begin{theorem}
\label{thm:ind-uf-OB-Enroll}
	Let $\textsf{option} = \{ \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{auth}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_{\textsf{option}}$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Enroll} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{R}$.

	\item $\mathcal{O}_\mathcal{B}$: This is simulated by the distribution $\mathcal{B}$ generated in Line \ref{alg:red:ind-uf-OB-Enroll:B}.
	
	\item $\mathcal{O}_{\textsf{auth}} (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{x}^\prime )$: This is simulated by $\mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^\prime, \mathbf{x}^\prime)$ given in the \textsf{fh-IND} game.
\end{itemize}

\noindent Note that since $\mathcal{R}$ never calls $\mathcal{O}_{\textsf{Enc}}$, it is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Enroll:B}

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$ \label{alg:red:ind-uf-OB-Enroll:c}

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{auth}, \mathcal{O}_\textsf{Enroll} } ( \mathbf{c})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Enroll:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

	If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_{\textsf{option}}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is $\Pr[\textsf{UF}_{\textsf{option}}(\mathcal{A}) \to 1]$.

	For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Enroll} in the $\textsf{RUF}$ game. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates each oracle in the following way. 

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{A}^\prime$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the oracle $\mathcal{O}_{\textsf{samp}}(i^*)$, where $i^*$ is an index that is never queried by $\mathcal{A}$ in $\mathcal{O}_{\textsf{samp}}$.

	\item $\mathcal{O}_{\textsf{auth}} (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{x}^\prime )$: This is simulated by $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ given in the \textsf{RUF} game. 
\end{itemize}

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.45\textwidth}
	\begin{algorithm}[H]
	\caption{${\mathcal{A}^\prime}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} }(\textsf{pp}, \mathbf{c})$}
	\label{alg:adv:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]

		\State $\mathbf{\tilde{z}} \gets {\mathcal{A}}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_\textsf{samp}(i^*), \mathcal{O}_\textsf{auth}, \mathcal{O}_\textsf{KeyGen}^\prime } ( \mathbf{c})$

		\State \Return $\mathbf{\tilde{z}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

Now, if the challenge bit $b = 1$, then $\mathcal{R}$ perfectly simulates $\mathcal{A}^\prime$ in the $\textsf{RUF}$ game. The probability that $\textsf{Verify}(s) = 1$, which is equivalent to $s \leq \tau^2$, in Line \ref{alg:red:ind-uf-OB-Enroll:verify} is $\Pr[\textsf{RUF}^{\tau^2}_{\textsf{FE}}(\mathcal{A}) \to 1 ]$

In conclusion, since $\gamma \geq \tau^2$,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 0] \right) \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 1] \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_{\textsf{option}}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}^{\tau^2}_{\textsf{FE}}(\mathcal{A}) \to 1 ] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}^{\gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] \right)
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ]$ are negligilbe,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \negl.
\]

\end{proof}


For $\textsf{option}$ that includes $\mathcal{O}_{\textsf{Probe}}$, we first note that for any $d \in \Z_q$ and any nonzero vector $\mathbf{r} \in \Z_q^{k+2}$, there exists a vector $\mathbf{y}$ such that $\mathbf{r}\mathbf{y}^T = d$.

\begin{theorem}
\label{thm:ind-uf-OB-Probe}

Let $\textsf{option} = \{\mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{auth}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{proof}

Given an adversary $\mathcal{A}$ in the $\textsf{UF}_\textsf{option}$ game, we will show that
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] = \negl.
\]
Hence, we can ignore the false positive rate $\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}^\prime_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1]$.

Consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:red:ind-uf-OB-Probe} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{R}$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the distribution $\mathcal{B}$ generated in Line \ref{alg:red:ind-uf-OB-Probe:B}.

	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}{\mathbf{y}^\prime}^T$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r}{\mathbf{y}^{\prime\prime}}^T = d$. Next, it calls $\mathcal{O}_{\textsf{Enc}}(\mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}})$, which is given by the \textsf{fh-IND} game, and returns the result.

\end{itemize}

\noindent Note that $(\mathbf{x}, \mathbf{r})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\mathbf{x}{\mathbf{y}^\prime}^T = \mathbf{r}{\mathbf{y}^{\prime\prime}}^T$. Hence, $\mathcal{R}$ is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$ \label{alg:red:ind-uf-OB-Probe:B}

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$

		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c})$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}_\textsf{Probe}$}

			\Return $\bot$

		\EndIf

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:red:ind-uf-OB-Probe:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF}_\textsf{option}$ game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:red:ind-uf-OB-Probe:verify} is $\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1]$.

For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^\prime$ in Algorithm \ref{alg:adv:ind-uf-OB-Probe} in the $\textsf{RUF}$ game. $\mathcal{A}^\prime$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{A}^\prime$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the oracle $\mathcal{O}_{\textsf{samp}}(i^*)$, where $i^*$ is an index that is never queried by $\mathcal{A}$ in $\mathcal{O}_{\textsf{samp}}$.

	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}^{(*)}{\mathbf{y}^\prime}^T$ and finds a vector $\mathbf{y}^{\prime\prime}$ such that $\mathbf{r}{\mathbf{y}^{\prime\prime}}^T = d$. Next, it calls $\mathcal{O}^\prime_{\textsf{Enc}} (\mathbf{y}^{\prime\prime} )$ , which is given by the $\textsf{RUF}$ game, and returns the result.

\end{itemize}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.8\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$ {\mathcal{A}^\prime}^{ \mathcal{O}^\prime_{\textsf{KeyGen}}, \mathcal{O}^\prime_{\textsf{Enc}} } (\textsf{pp}, \mathbf{c}) $}
	\label{alg:adv:ind-uf-OB-Probe}
	\begin{algorithmic}[1]
		\State $\mathbf{x}^{(*)} \gets \textsf{encodeEnroll}^{ \mathcal{O}_\textsf{samp}(i^*)} ()$

		\State Sample $k+2$ linearly independent vectors $\{ \mathbf{e}^{(i)} \}_{i=1}^{k+2}$.

		\For{$i=1$ to $k+2$}
			\State $\mathbf{c}^{(i)} \gets \mathcal{O}^\prime_{\textsf{Enc}}(\mathbf{e}^{(i)})$.

			\State $d_i \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{c}^{(i)})$.
		\EndFor

		\State Find the vector $\mathbf{r}$ by solving the linear system $\{ \mathbf{r} {\mathbf{e}^{(i)}}^T = d_i \}_{i=1}^{k+2}$.

		\If{$\mathbf{r} = \mathbf{0}$}

			\State \Return $\bot$

		\EndIf

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\textsf{samp}}(i^*), \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c})$
		
		\State \Return ${\mathbf{\tilde{z}}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

To make $\mathcal{R}$ simulate $\mathcal{A}^\prime$ in the $\textsf{RUF}$ game, we still need to ensure two conditions.

\begin{itemize}

	\item $\mathbf{r} \neq \mathbf{0}$. Otherwise, $\mathcal{A}^\prime$ cannot simulate $\mathcal{O}_\textsf{Probe}$. 

	\item $\mathbf{\tilde{z}} \neq \mathbf{c}^{(i)}$ for all $i$. The answers of $\mathcal{O}_\textsf{Probe}$ have already been checked in $\mathcal{R}$. 
\end{itemize}

Let $\mathcal{A}^\prime$ play a tweaked $\textsf{RUF}_\textsf{FE}^{\tau^2}$ game which does not check that $\mathbf{\tilde{z}}$ is not equal to $\mathbf{c}^{(i)}$ for all $i$. That is, the game only checks whether $\mathbf{\tilde{z}}$ is not equal to any output of $\mathcal{O}^\prime_\textsf{Enc}$ called by $\mathcal{O}_\textsf{Probe}$ of $\mathcal{A}$. Let the returned value of this game be $V$. We have Equation \ref{equ:ind-uf-OB-Probe:1} and \ref{equ:ind-uf-OB-Probe:2}. The former one is a relation between $\mathcal{R}$ playing $\textsf{fh-IND}$ game when the challenge bit $b=1$ and $V$, and the other one is a relation between $\mathcal{A}^\prime$ playing a regular $\textsf{RUF}_\textsf{FE}^{\tau^2}$ game and the tweaked one.

\begin{gather}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] = \Pr[V = 1] \label{equ:ind-uf-OB-Probe:1} \\
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] = \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right] \label{equ:ind-uf-OB-Probe:2}
\end{gather}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:1}, consider that

\begin{align*}
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1]
	&= \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} \neq \mathbf{0}] \cdot \Pr[\mathbf{r} \neq \mathbf{0}] \\
	&+ \Pr[\textsf{Verify}(s) = 1 \mid b = 1 \wedge \mathbf{r} = \mathbf{0}] \cdot \Pr[\mathbf{r} = \mathbf{0}] \\
	&\leq \Pr[V = 1] + \Pr[\mathbf{r} = 0] \\
	&= \Pr[V = 1] + \frac{1}{q^{k+2}} 
\end{align*}

\noindent For Equation \ref{equ:ind-uf-OB-Probe:2}, consider that

\begin{align*}
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] 
	&= \Pr\left[ V = 1 \mid \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right] \\ 
	& \geq \Pr[V = 1] - \Pr \left[ \neg  \left( \bigwedge_{i=1}^{k+2} \mathbf{\tilde{z}} \neq \mathbf{c}^{(i)} \right) \right] \\
	& = \Pr[V = 1] - \Pr \left[ \bigvee_{i=1}^{k+2} \mathbf{\tilde{z}} = \mathbf{c}^{(i)} \right] \\
	& \geq \Pr[V = 1] - \sum_{i=1}^{k+2} \Pr[\mathbf{\tilde{z}} = \mathbf{c}^{(i)}].
\end{align*}

\noindent Note that each $\mathbf{c}^{(i)} = \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{e}^{(i)})$ for some uniform nonzero vector $\mathbf{e}^{(i)}$. Also note that distinct vectors in $\Z_q^{k+2}$ will have different encryptions due to the correctness of $\textsf{FE}$. Therefore, $\Pr[\mathbf{\tilde{z}} = \mathbf{c}^{(i)}] \leq \frac{1}{q^{k+2} - 1}$ and
\[
	\Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] \geq \Pr[V = 1] - \frac{k+2}{q^{k+2}-1}.
\]

\noindent Combining both results from Equation \ref{equ:ind-uf-OB-Probe:1} and Equation \ref{equ:ind-uf-OB-Probe:2}, we derive
\[
	\Pr[\textsf{Verify}(s) = 1 \mid b = 1] \leq \Pr[V = 1] + \frac{1}{q^{k+2}} \leq \Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}}.
\]

Finally, similar to the proof of Theorem \ref{thm:ind-uf-OB-Enroll}, we derive
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1]
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}_\textsf{FE}^{\tau^2}(\mathcal{A}^\prime) \to 1] - \frac{k+2}{q^{k+2}-1} - \frac{1}{q^{k+2}} \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] - \Pr[\textsf{RUF}_\textsf{FE}^{\gamma}(\mathcal{A}^\prime) \to 1] - \frac{k+2}{q^{k+2}-1} - \frac{1}{q^{k+2}} \right) \\
\end{align*}

\noindent Since both $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ and $\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} = \Pr[\textsf{RUF}^\gamma_{\textsf{FE}}(\mathcal{A}) \to 1 ]$ are negligible,
\[
	\Pr[\textsf{UF}_\textsf{option}(\mathcal{A}) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \gamma} + \frac{k+2}{q^{k+2}-1} + \frac{1}{q^{k+2}} = \negl.
\]

\end{proof}


%-------------------
\newpage

\section{Rough Ideas}

Define the $\textsf{RUF}^\mathcal{O}$ game in algorithm \ref{alg:oracle-ruf-fh-IPFE} for a real number $\gamma$.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.55\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:oracle-ruf-fh-IPFE}
	\begin{algorithmic}[1]
		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$ \label{alg:ruf-fh-IPFE:r}

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$

		\State $\mathbf{\tilde{z}} \gets \mathcal{A}^{\mathcal{O}} ( \textsf{pp}, \mathbf{c} )$

		\If{$\mathbf{\tilde{z}}$ is equal to any output of $\mathcal{O}^\prime_{\textsf{Enc}}$ }
			
			\State \Return $0$
		
		\EndIf

		\State $s \gets \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}} )$

		\State \Return $1_{s \leq \gamma}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\end{figure}

The oracle $\mathcal{O}$ can be nothing or includes the following options based on the threat model.

\begin{itemize}

	\item $\mathcal{O}^\prime_{\textsf{KeyGen}}(\cdot)$: On input $\mathbf{x}^\prime$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^\prime)$.
	
	\item $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$: On input $\mathbf{y}^\prime$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^\prime)$. The adversary is required to return $\mathbf{\tilde{z}}$ that is not equal to any output of this oracle.
\end{itemize}


\begin{definition}[RUF Security]

	An fh-IPFE scheme \textsf{FE} is called $\mathcal{O}$-RUF secure for a real number $\gamma$ if for any adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the \textsf{RUF} game in Algorithm \ref{alg:ruf-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{RUF}, \mathcal{O}, \gamma} := \Pr[\textsf{RUF}^{\mathcal{O}, \gamma}_{\textsf{FE}}(\mathcal{A}) \to 1 ] = \negl.
\]

\end{definition}

\begin{theorem}[Theorem \ref{thm:ind-uf-OB-Enroll}]
	Let $\textsf{option} = \{ \mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{auth}, \mathcal{O}_{\textsf{Enroll}} \}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}


\begin{theorem}[Theorem \ref{thm:ind-uf-OB-Probe}]
	Let $\textsf{option} = \{\mathbf{c_x}, \mathcal{O}_\mathcal{B}, \mathcal{O}_\textsf{auth}, \mathcal{O}_\textsf{Probe}\}$. For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure and $\mathcal{O}^\prime_{\textsf{Enc}}(\cdot)$-RUF secure for a $\gamma \geq \tau^2$, then $\Pi$ is $\textsf{option}$-unforgeable. 
\end{theorem}




\begin{assumption}
\label{assump}
Let $\mathbf{x} \in \mathbb{F}^k, \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$. Assume that $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z})$ only returns when $\mathbf{z}$ corresponds to a \emph{nonzero} vector $\mathbf{v} \in \mathbb{F}^k$. That is, assume that for any $\mathbf{z}$, there can only be two possibilities.

\begin{itemize}
	\item There exists a vector $\mathbf{v} \in \mathbb{F}^k, \mathbf{v} \neq \mathbf{0}$ such that for any $\mathbf{x} \in \mathbb{F}^k$ and $ \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) = \mathbf{x}\mathbf{v}^T$.

	\item For any $\mathbf{x} \in \mathbb{F}^k$ and $ \mathbf{c} \gets \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x})$, $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{z}) \to \bot$.

\end{itemize}
Note that this implies $\textsf{FE}$ rejects zero vector $\mathbf{0}$ as the input of $\textsf{FE.Enc}$.
\end{assumption}

\begin{theorem}
	Given Assumption \ref{assump}. If \textsf{FE} is fh-IND secure, then $\textsf{FE}$ is $\mathcal{O}^\prime_{\textsf{KeyGen}}$-RUF secure for any $\gamma < \|\mathbb{F}\|$. 
\end{theorem}

\begin{proof}
Given an adversary $\mathcal{A}$ in the $\textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}$ game for any $\gamma < \|\mathbb{F}\|$, consider the reduction adversary $\mathcal{R}$. $\mathcal{R}$ simulates $\mathcal{O}_\textsf{KeyGen}^\prime(\mathbf{x}^\prime)$ by $\mathcal{O}_\textsf{KeyGen}(\mathbf{x}^\prime, \mathbf{x}^\prime)$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:red:ind-uf-OB-Enroll}
	\begin{algorithmic}[1]
		\State $\mathbf{r}^{(0)} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\mathbf{r}^{(1)} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}^{(1)})$ 

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}}^{\mathcal{O}^\prime_{\textsf{KeyGen}}} ( \mathbf{c})$

		\State $\mathbf{c}^{(0)} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{r}^{(0)}, \mathbf{r}^{(0)})$ 
		
		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}^{(0)}, \mathbf{\tilde{z}} )$
		
		\If{$s \leq \gamma$} \label{alg:red:ind-ruf:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\end{figure}

If $s \neq \bot$, by Assumption \ref{assump}, let $\mathbf{\tilde{z}}$ correspond to a vector $\mathbf{\tilde{v}}$.

If the challenge bit $b = 0$, then the probability that $s \leq \gamma$ in Line \ref{alg:red:ind-ruf:verify} is
\begin{align*}
	Pr[ s \leq \gamma \mid b = 0 ]
	&= \Pr[s \neq \bot \mid b = 0] \cdot \Pr[ s \leq \gamma \mid b = 0 \wedge s \neq \bot] \\
	&= \Pr[s \neq \bot \mid b = 0] \cdot \Pr[ \mathbf{r}^{(0)} \mathbf{\tilde{v}}^T \leq \gamma \mid b = 0 \wedge s \neq \bot] \\
	&= \Pr[s \neq \bot \mid b = 0] \cdot \Pr[ \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \leq \gamma \mid b = 0 \wedge s \neq \bot] 
\end{align*}
By Assumption \ref{assump}, $s = \textsf{FE.Dec}( \textsf{pp}, \mathbf{c}^{(0)}, \mathbf{\tilde{z}} ) \neq \bot$ if and only if $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \neq \bot$ and independet of $b$. Hence,
\[
	Pr[ s \leq \gamma \mid b = 0 ] = \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]
\]

If the challenge bit $b = 1$,
\begin{align*}
	Pr[ s \leq \gamma \mid b = 1 ]
	&= \Pr[s \neq \bot \mid b = 1] \cdot \Pr[ s \leq \gamma \mid b = 1 \wedge s \neq \bot] \\
	&= \Pr[s \neq \bot \mid b = 1] \cdot \Pr[ \mathbf{r}^{(0)} \mathbf{\tilde{v}}^T \leq \gamma \mid b = 1 \wedge s \neq \bot]
\end{align*}
Note that $\mathbf{r}^{(0)}$ is independent of $\mathbf{\tilde{z}}$ and thus $\mathbf{\tilde{v}}$, so $\Pr[\mathbf{r}^{(0)} \mathbf{\tilde{v}}^T \leq \gamma] = \frac{\gamma}{\| \mathbb{F} \|}$ and
\[
	Pr[ s \leq \gamma \mid b = 1 ] = \Pr[s \neq \bot \mid b = 1] \cdot \frac{\gamma}{\| \mathbb{F} \|}
\]
Again, by Assumption \ref{assump}, $s \neq \bot$ if and only if $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \neq \bot$. Hence,
\begin{align*}
	Pr[ s \leq \gamma \mid b = 1 ] 
	&= \Pr[\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \neq \bot \mid b = 1] \cdot \frac{\gamma}{\| \mathbb{F} \|} \\
	& \geq \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] \cdot \frac{\gamma}{\| \mathbb{F} \|}
\end{align*}

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \left( \Pr[s \leq \gamma \mid b = 0] + \frac{1}{2} \Pr[s > \gamma \mid b = 0] \right) \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \Pr[s > \gamma \mid b = 1] \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[s \leq \gamma \mid b = 0] - \Pr[s \leq \gamma \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] - \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1] \cdot \frac{\gamma}{\| \mathbb{F} \|} \right) \\
	&=\frac{1}{2} + \frac{1}{4} \left( 1 - \frac{\gamma}{\| \mathbb{F} \|} \right) \left( \Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \right)
\end{align*}

\noindent Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right|$ is negligible,
\[
	\Pr[ \textsf{RUF}^{\mathcal{O}^\prime_{\textsf{KeyGen}}, \gamma}(\mathcal{A}) \to 1]  \leq 4 \cdot \left( \frac{ \| \mathbb{F} \|}{\| \mathbb{F} \| - \gamma}\right) \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND}  = \negl.
\]

\end{proof}
\newpage








%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\nocite{*}
\printbibliography


\end{document}
