%%%%%%%%%%%%%%%%%%%%

% Semester Project Fall 2024 for EPFL
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Semester Project}
\fancyhead[C]{Biometric Authentication}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------

This report formalizes the biometric authentication scheme, including its structure, usage, and security analysis with a security game model.

%-------------------

\section{Preliminaries}
\label{sec:preliminaries}

In this report, we assume

\begin{itemize}
	
	\item $\lambda$ is the security parameter.

	\item $[m]$ denotes the set of integers $\{1, 2, \cdots, m\}$.

	\item $\Z_q$ is the finite field modulo a prime number $q$.

	\item A function $f(n)$ is called \emph{negligible} iff for any integer $c$, $f(n) < \frac{1}{n^c}$ for all sufficiently large $n$. We write it as $f(n) = \negl$, and we may also use $\negl$ to represent an arbitrary negligible function.
	
	\item $\poly$ is the class of polynomial funcions. We may also use $\poly$ to represent an arbitrary polynomial function.
	
	\item We write sampling a value $r$ from a distribution $\mathcal{D}$ as $r \getsdollar \mathcal{D}$. If $S$ is a finite set, then $r \getsdollar S$ means sampling $r$ uniformly from $S$.

	\item The distribution $\mathcal{D}^t$ denotes $t$ identical and independent distributions of $\mathcal{D}$.

	\item A PPT algorithm denotes a probabilistic polynomial time algorithm. Unless otherwise specified, all algorithms run in PPT.

\end{itemize}


\begin{definition}[Functional Hiding Inner Product Functional Encryption]
\label{def:fh-IPFE}
	A \emph{functional hiding inner product functional encryption} (fh-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms ${\sf FE.Setup}$, ${\sf FE.KeyGen}$, ${\sf FE.Enc}$, and ${\sf FE.Dec}$:

	\begin{itemize}
	
		\item ${\sf FE.Setup}(1^\lambda) \to {\sf msk}, {\sf pp}$: It outputs the public parameter ${\sf pp}$ and the master secret key ${\sf msk}$.
	
		\item ${\sf FE.KeyGen}({\sf msk}, {\sf pp}, \mathbf{x}) \to f_\mathbf{x}$: It generates the functional decryption key $f_\mathbf{x}$ for an input vector $\mathbf{x} \in \mathbb{F}^k$. 
	
		\item ${\sf FE.Enc}({\sf msk}, {\sf pp}, \mathbf{y}) \to \mathbf{c_y}$: It encrypts the input vector $\mathbf{y} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_y}$. 
	
		\item ${\sf FE.Dec}({\sf pp}, f_\mathbf{x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The fh-IPFE scheme {\sf FE} is \emph{correct} if $\forall ({\sf msk}, {\sf pp}) \gets {\sf FE.Setup}(1^\lambda)$ and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		{\sf FE.Dec}( {\sf pp}, {\sf FE.KeyGen}({\sf msk}, {\sf pp}, \mathbf{x}), {\sf FE.Enc}({\sf msk}, {\sf pp}, \mathbf{y}) ) = \mathbf{x} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}


\begin{definition}[Two-Input Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2i-IPFE}
	A \emph{two-input inner product functional encryption} (2i-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms ${\sf FE.Setup}$, ${\sf FE.KeyGen}$, ${\sf FE.Enc}$, and ${\sf FE.Dec}$:

	\begin{itemize}
	
		\item ${\sf FE.Setup}(1^\lambda) \to {\sf sk}, {\sf ek}_1, {\sf ek}_2$: It outputs a secret key ${\sf sk}$ and two encryption keys ${\sf ek}_1, {\sf ek}_2$.
	
		\item ${\sf FE.KeyGen}({\sf sk}, \mathbf{A}) \to {\sf dk}_\mathbf{A}$: It generates the functional decryption key ${\sf dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item ${\sf FE.Enc}({\sf ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given an encryption key, either ${\sf ek}_1$ or ${\sf ek_2}$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item ${\sf FE.Dec}({\sf dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2i-IPFE scheme {\sf FE} is \emph{correct} if $\forall ({\sf sk}, {\sf ek}_1, {\sf ek}_2) \gets {\sf FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, and $\mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have

	\[
		{\sf FE.Dec}({\sf FE.KeyGen}({\sf sk},  \mathbf{A}), {\sf FE.Enc}({\sf ek}_1, \mathbf{x}), {\sf FE.Enc}({\sf ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}


\begin{definition}[Two-Client Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2c-IPFE}
	A \emph{two-client inner product functional encryption} (2c-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms ${\sf FE.Setup}$, ${\sf FE.KeyGen}$, ${\sf FE.Enc}$, and ${\sf FE.Dec}$:

	\begin{itemize}
	
		\item ${\sf FE.Setup}(1^\lambda) \to {\sf sk}, {\sf ek}_1, {\sf ek}_2$: It outputs a secret key ${\sf sk}$ and two encryption keys ${\sf ek}_1, {\sf ek}_2$.
	
		\item ${\sf FE.KeyGen}({\sf sk}, \mathbf{A}) \to {\sf dk}_\mathbf{A}$: It generates the functional decryption key ${\sf dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item ${\sf FE.Enc}(\ell, {\sf ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given a label $\ell$ and an encryption key, either ${\sf ek}_1$ or ${\sf ek_2}$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item ${\sf FE.Dec}({\sf dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2c-IPFE scheme {\sf FE} is \emph{correct} if $\forall ({\sf sk}, {\sf ek}_1, {\sf ek}_2) \gets {\sf FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, label $\ell$, and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		{\sf FE.Dec}({\sf FE.KeyGen}({\sf sk},  \mathbf{A}), {\sf FE.Enc}(\ell, {\sf ek}_1, \mathbf{x}), {\sf FE.Enc}(\ell, {\sf ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}


%-------------------

\section{Formalization}
\label{sec:formalization}


In general, an authentication shceme $\Pi$ associated with a family of biometric distributions $\mathbb{B}$ is composed of the following algorithms.

\begin{itemize}

	\item ${\sf Setup}(1^\lambda) \to {\sf esk}, {\sf psk}, {\sf csk}$: It outputs the enrollment secret key ${\sf esk}$, probe secret key ${\sf psk}$, and compare secret key $\sf csk$.

	\item ${\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{x}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{x}$, the input format for enrollment. 

	\item ${\sf Enroll}({\sf esk}, \mathbf{x}) \to \mathbf{c_x}$: It outputs the enrollment message $\mathbf{c_x}$ from $\mathbf{x}$.

	\item ${\sf encodeProbe}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{y}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{y}$, the input format for probe.

	\item ${\sf Probe}({\sf psk}, \mathbf{y}) \to \mathbf{c_y}$: It outputs the probe message $\mathbf{c_y}$ from $\mathbf{y}$.

	\item ${\sf Compare}({\sf csk}, \mathbf{c_x}, \mathbf{c_y)} \to s$: It compares the enrollment message $\mathbf{c_x}$ and probe message $\mathbf{c_y}$ and outputs a score $s$.

	\item ${\sf Verify}(s) \to r \in \{0,1\}$: It is a deterministic algorithm that reads the comparison score $s$ and determines whether this is a successful authentication ($r = 1$) or not ($r = 0$).

\end{itemize}

\noindent 
We discuss two usage models that employs the authentication scheme $\Pi$.


\subsection{Usage Model – Device-of-User}
\label{sec:dou_model}

In the model described in Figure \ref{fig:model_dou_overview} (an overview), Figure \ref{fig:model_dou_enrollment} (on enrollment), and Figure \ref{fig:model_dou_auth} (on authentication), users authenticate themselves to a server through their own devices and biometric scanners that are shared among different users.
A key distribution service distributes keys for them. In practice, this model applies to the situation when the users access an online service run by the server.

\begin{itemize}

	\item {\sf User}: The user who enrolls its biometric data and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$. 

	\item {\sf Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item {\sf Device}: A device belonging to the user. In practice, it can be a desktop or a mobile phone. It processes the {\sf Enroll} and {\sf Probe} functions for ${\sf User}$ with keys {\sf esk} and {\sf psk}. It queries $\mathcal{O}_{\mathcal{B}}$ for biometric data through the {\sf Scanner}.
	
	\item {\sf KDS}: A key distribution service. It runs ${\sf Setup}$ to generate keys and distribute them to ${\sf Device}$ and ${\sf Server}$.
		
	\item {\sf Server}: The server responsible for authenticating the user. It stores the comparison key {\sf csk} and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}


\input{tikz/dou_model.tex}

\pagebreak
%-------------------

\subsection{Usage Model – Device-of-Domain}
\label{sec:dod_model}

In the model described in Figure \ref{fig:model_dod_overview} (an overview), Figure \ref{fig:model_dod_enrollment} (on enrollment), and Figure \ref{fig:model_dod_auth} (on authentication), users first enroll themselves at an enrollment station and then authenticate themselves to a server through devices that belong to a domain.
A key distribution service distributes enrollment keys to the enrollment station, probe keys to the domain, and comparison keys to the server. In practice, a domain can be a department in an organization, and this models applies to the situation when a user wants to access a public service of a department, such as a restricted area or instruments. 

\begin{itemize}

	\item {\sf User}: The user who enrolls its biometric data at an enrollment station and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$.
	
	\item {\sf Domain}: A domain that owns several devices, all of which share one enrollment key ${\sf esk}$, one probe key ${\sf psk}$ and one comparison key ${\sf csk}$. Only the probe key is stored at each device of a domain. The enrollment key is stored at the enrollment station, and the comparison key is stored at the server. In practice, a domain can be a department, and users enroll and authenticate themselves before accessing a restricted service of this department.

	\item {\sf Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item {\sf Station}: An enrollment station responsible for collecting the user's biometric data to enroll them for a domain on the server.

	\item {\sf Device}: A device belonging to a domain. In practice, it can be a device checking identities for a restricted area or an instrument. It owns a probe key $\sf psk$ and processes the $\sf Probe$ function for enrolled users of this domain.
	
	\item {\sf KDS}: A key distribution service. It runs ${\sf Setup}$ to generate keys and distribute them to {\sf Station}, {\sf Domain}, and {\sf Server}.
		
	\item {\sf Server}: The server responsible for authenticating the user. It stores the comparison key {\sf csk} for each domain and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}


%-------------------

\input{tikz/dod_model.tex}

\pagebreak

%-------------------

\subsection{Instantiation with an fh-IPFE Scheme}
\label{sec:fh-IPFE-instantiation}

Let ${\sf FE} = ({\sf FE.Setup}, {\sf FE.KeyGen}, {\sf FE.Enc}, {\sf FE.Dec})$ be an fh-IPFE scheme we defined in Definition \ref{def:fh-IPFE}. Following \cite{cryptoeprint:2023/481}, we can instantiate a biometric authentication scheme using ${\sf FE}$ with the distance metric the Euclidean distance. Let the biometric templates $\mathbf{b}$ and $\mathbf{b'}$ be sampled from some distribution $\mathcal{B} \subseteq [m]^k$, and let the associated field of ${\sf FE}$ be $\mathbb{Z}_q$ where $q$ is a prime number larger than the maximum possible Euclidean distance $m^2 \cdot k$. The scheme is instantiated as follows.

\begin{itemize}

	\item ${\sf Setup}(1^\lambda)$: It calls ${\sf FE.Setup}(1^\lambda) \to {\sf msk}, {\sf pp}$ and outputs ${\sf esk} \gets ({\sf msk}, {\sf pp})$, ${\sf psk} \gets ({\sf msk}, {\sf pp})$ and ${\sf csk} \gets {\sf pp}$.

	\item ${\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b} = (b_1, b_2, \cdots, b_k)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{x} = (x_1, x_2, \cdots, x_{k+2}) = (b_1, b_2, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. 

	\item ${\sf Enroll}({\sf esk}, \mathbf{x})$: It calls ${\sf FE.KeyGen}({\sf msk}, {\sf pp}, \mathbf{x}) \to f_\mathbf{x}$ and outputs $\mathbf{c_x} \gets f_\mathbf{x}$.

	\item ${\sf encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b'} = (b_1', b_2', \cdots, b_k')$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{y} = (y_1, y_2, \cdots, y_{k+2}) = (-2b_1', -2b_2', \cdots, -2b_k', \|\mathbf{b'}\|^2, 1)$.

	\item ${\sf Probe}({\sf psk}, \mathbf{y})$: It calls ${\sf FE.Enc}({\sf msk}, {\sf pp}, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item ${\sf Compare}({\sf csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls ${\sf FE.Dec}({\sf pp}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item ${\sf Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = {\sf FE.Dec}({\sf pp}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{y}^T = \sum_{i=1}^k -2b_ib_i' + \|\mathbf{b}\|^2 + \|\mathbf{b'}\|^2 = \| \mathbf{b} - \mathbf{b'} \|^2.
\]

which is the square of the Euclidean distance between two templates $\mathbf{b}$ and $\mathbf{b}'$. Therefore, if two templates $\mathbf{b}$ and $\mathbf{b}'$ are close enough such that $\|\mathbf{b} - \mathbf{b'}\| < \tau$, the scheme results in $r = 1$, a successful authentication.


Instantiated with an fh-IPFE scheme in this way, the comparison secret key ${\sf csk}$ is public, and the enrollment secret key ${\sf esk}$ and probe secret key ${\sf psk}$ are the same. Anyone with access to the enrollment message $\mathbf{c_x}$ and either one of ${\sf esk}$, ${\sf psk}$, or a probe oracle ${\sf Probe}({\sf psk}, \cdot )$ can probe some $\mathbf{y}^{\prime} \in \mathbf{F}^{k+2}$ and find $\mathbf{x} {\mathbf{y}^\prime}^T$ to get partial or full information about $\mathbf{x}$. Even if the adversary can only sample random ciphertexts $\mathbf{c_{y}}$ without knowing $\mathbf{y}$, if the field size $q$ is not large enough, one can find a forged $\mathbf{c_{y^*}}$ such that $\mathbf{x}\mathbf{y^*}^T < \tau$ to impersonate the user by sampling many times offline.

Therefore, {\sf Server} must store $\mathbf{c_x}$ securely, to avoid such an attack from an adversary who can access the probe oracle; {\sf Device} must protect its probe function, to avoid such an attack from a malicious {\sf Server}. 

In the Device-of-Domain model, we assume the probe oracle is public, just as everyone can try accessing a public service. A malicious {\sf Station} or {\sf Server}, who has the enrollment message $\mathbf{c_x}$, can utilize this attack to retrieve information about {\sf User}.


%-------------------


\subsection{Instantiation with a 2i-IPFE Scheme}
\label{sec:2i-IPFE-instantiation}

Let ${\sf FE} = ({\sf FE.Setup}, {\sf FE.KeyGen}, {\sf FE.Enc}, {\sf FE.Dec})$ be a 2i-IPFE scheme we defined in Definition \ref{def:2i-IPFE}. Following the scheme in Section \ref{sec:fh-IPFE-instantiation}, we can instantiate a biometric authentication scheme using ${\sf FE}$.

\begin{itemize}

	\item ${\sf Setup}(1^\lambda)$: It calls ${\sf FE.Setup}(1^\lambda) \to {\sf sk}, {\sf ek}_1, {\sf ek}_2$, $ {\sf dk}_{\mathbf{I}} \gets {\sf FE.KeyGen}(sk, \mathbf{I}_{k+2})$, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. It outputs ${\sf esk} \gets {\sf ek}_1$, ${\sf psk} \gets {\sf ek}_2$, and ${\sf csk} \gets {\sf dk}_{\mathbf{I}}$

	\item ${\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), {\sf encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:fh-IPFE-instantiation}. 

	\item ${\sf Enroll}({\sf esk}, \mathbf{x})$: It calls ${\sf FE.Enc}({\sf ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item ${\sf Probe}({\sf psk}, \mathbf{y})$: It calls ${\sf FE.Enc}({\sf ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item ${\sf Compare}({\sf csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls ${\sf FE.Dec}({\sf dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item ${\sf Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = {\sf FE.Dec}({\sf dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \mathbf{x} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b'} \|^2.
\]
just as the scheme in Section \ref{sec:fh-IPFE-instantiation}


Unlike the previous scheme, instantiated with a 2i-IPFE scheme in this way, the comparison secret key ${\sf csk}$ is now secret, and the enrollment secret key ${\sf esk}$ and probe secret key ${\sf psk}$ are distinct. Without ${\sf csk}$, one cannot compare an enrollment message $\mathbf{c_x}$ and a probe message $\mathbf{c_y}$. We can also transmit $\mathbf{c_x}$ in a public channel and store it in a public storage, under necessary security requirements of the 2i-IPFE scheme, such as indistinguishability of $\mathbf{c_x}$.

In the Device-of-Domain model, the indistinguishability of $\mathbf{c_x}$ is against an adversary who has a probe oracle ${\sf Probe}({\sf psk}, \cdot)$. If {\sf Server} is malicious, then it can use ${\sf csk}$ to distinguish $\mathbf{c_x}$ enrolled by different samples. Therefore, we must limit the adversary's ability. For example, we can require the adversary to distinguish biometric vectors sampled from distributions in a pre-defined pool, and the adversary can only probe vectors randomly sampled from a distribution in the pool. We can also limit the rate of the probe oracle.

%-------------------

\subsection{Instantiation with a 2c-IPFE Scheme}
\label{sec:2c-IPFE-instantiation}

Note that if labels remain constant, a 2c-IPFE scheme is reduced to a 2i-IPFE scheme. Therefore, we can consider utilizing the label to represent each domain in the Device-of-Domain model. Let ${\sf FE} = ({\sf FE.Setup}, {\sf FE.KeyGen}, {\sf FE.Enc}, {\sf FE.Dec})$ be a 2c-IPFE scheme we defined in Definition \ref{def:2c-IPFE}. Following the scheme in Section \ref{sec:2i-IPFE-instantiation}, we can instantiate a biometric authentication scheme using ${\sf FE}$.

\begin{itemize}

	\item ${\sf Setup}(1^\lambda)$: It calls ${\sf FE.Setup}(1^\lambda) \to {\sf sk}, {\sf ek}_1, {\sf ek}_2$, $ {\sf dk}_{\mathbf{I}} \gets {\sf FE.KeyGen}(sk, \mathbf{I}_{k+2})$, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. For keys used for {\sf Domain} $\ell$, it outputs ${\sf esk} \gets (\ell, {\sf ek}_1)$, ${\sf psk} \gets (\ell, {\sf ek}_2)$, and ${\sf csk} \gets {\sf dk}_{\mathbf{I}}$.

	Note that when the previous 2i-IPFE-based scheme in Section \ref{sec:2i-IPFE-instantiation} is applied to a Device-of-Domain model, we assume that ${\sf Setup}$ is run once for each domain to generate different ${\sf esk}, {\sf psk}, {\sf csk}$. In the scheme in this section, however, ${\sf Setup}$ is run only once for all the domains, and each domain shares the same ${\sf csk}$ and the same ${\sf esk}, {\sf psk}$ except different labels.

	\item ${\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), {\sf encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:2i-IPFE-instantiation}. 

	\item ${\sf Enroll}({\sf esk}, \mathbf{x})$: It calls ${\sf FE.Enc}(\ell, {\sf ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item ${\sf Probe}({\sf psk}, \mathbf{y})$: It calls ${\sf FE.Enc}(\ell, {\sf ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item ${\sf Compare}({\sf csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls ${\sf FE.Dec}({\sf dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item ${\sf Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, if the labels of $\mathbf{c_x}$ and $\mathbf{c_y}$ are the same (they are of the same domain), we have
\[
	s = {\sf FE.Dec}({\sf dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b'} \|^2.
\]
just as the scheme in Section \ref{sec:2i-IPFE-instantiation}

When the Device-of-Domain model is instantiated with a 2c-IPFE scheme in this way, the enrollment secret key ${\sf esk}$ and probe secret key ${\sf psk}$ are now shared among all the devices, regardless of their domains. Therefore, to let a malicious or broken {\sf Domain} not threaten other honest ones, one needs to make sure given ${\sf esk}$ or ${\sf psk}$, $\mathbf{c_x}$ still does not leak information about $\mathbf{x}$. This is different from the scheme in Section \ref{sec:2i-IPFE-instantiation}, where we only need seurity against an adversary who has a probe oracle ${\sf Probe}({\sf psk}, \cdot)$.

If {\sf Server} and {\sf Domain} are both malicious, then the adversary can use ${\sf csk}$ to distinguish $\mathbf{c_x}$ and even recover $\mathbf{x}$. Therefore, we assume at most one party of them can be malicious at the same time. Note that this is the same as the 2i-IPFE-based scheme, where only one of {\sf Server} and {\sf Domain} can be malicious.

%-------------------


\section{Security Games}

From now on, we consider a family of biometric distributions $\mathbb{B}$. Removing a person $\mathcal{B}$ from $\mathbb{B}$ is written as $\mathbb{B} \setminus \mathcal{B}$. To model the knowledge about the biometric distributions, we offer an oracle $\mathcal{O}_{\sf samp}(i)$ to all adversaries in this section.

\begin{itemize}
	\item $\mathcal{O}_{\sf samp}(\cdot)$: On input an index $i$,
	\begin{itemize}
		\item If $i$ was not queried before, it first samples a biometric distribution $\mathcal{B}_i \in \mathbb{B}$ and then outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}_i$.
		\item If $i$ has been queried before, it outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}_i$.
	\end{itemize}
\end{itemize}



\subsection{Unforgeability against Malicious Scanner (UF-MSC)}
\label{sec:uf-msc_game}

In the game of Unforgeability against Malicious Scanner (UF-MSC), we model the ability of a malicious {\sf Scanner} in the Device-of-User model who has access to {\sf Server}'s database of registered enrollments and tries to impersonate the user. The adversary $\mathcal{A}$ is given the enrollment message $\mathbf{c_x}$ and oracle $\mathcal{O}$ and tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game is defined in Algorithm \ref{alg:uf-msc_game}.


\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.45\linewidth}
	\begin{algorithm}[H]
	\caption{${\sf UF-MSC}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:uf-msc_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State ${\sf esk}, {\sf psk}, {\sf csk} \gets {\sf Setup}(1^\lambda)$

		\State $\mathbf{x} \gets {\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets {\sf Enroll}({\sf esk}, \mathbf{x})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O} } ( \mathbf{c_x} )$

		\State $s \gets {\sf Compare}( {\sf csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return ${\sf Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	\begin{minipage}[t]{0.45\linewidth}
	\begin{algorithm}[H]
	\caption{${\sf UF-MSC^\prime}_{\Pi, \mathbb{B}}(\mathcal{A^\prime})$}
	\label{alg:plain_uf-msc_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State ${\sf esk}, {\sf psk}, {\sf csk} \gets {\sf Setup}(1^\lambda)$

		\State $\mathbf{x} \gets {\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets {\sf Enroll}({\sf esk}, \mathbf{x})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A'}^{\mathcal{O}_{\sf auth}^{q}}()$

		\State $s \gets {\sf Compare}( {\sf csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return ${\sf Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\caption{The UF-MSC Game (Left) and Plain UF-MSC Game (Right)}
\label{fig:uf-msc_game}
\end{figure}

The given oracle $\mathcal{O}$ consists of the following oracles:

\begin{itemize}
	\item $\mathcal{O}_{\mathcal{B}}$: It outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}$.

	\item $\mathcal{O}_{\sf auth}^{q}({\sf csk}, \mathbf{c_x}, \cdot)$: This is a resource-limited oracle. If it has been queried over $q$ times in total, it aborts. Otherwise, on input $\mathbf{z}$, it outputs ${\sf Verify}({\sf Compare}({\sf csk}, \mathbf{c_x}, \mathbf{z}))$.
\end{itemize}

Note that if the the comparison secret key ${\sf csk}$ is an empty or public string in the scheme, then the oracle $\mathcal{O}_{\sf auth}^{q}$ is useless since the adversary can run $\sf Compare$ with $\mathbf{c_x}$ itself.

To consider potential false positives of biometrics match, we consider the plain UF-MSC game in Algorithm \ref{alg:plain_uf-msc_game}, in which the adversary does not have any knowledge about the template.

We define the advantage of an adversary $\mathcal{A}$ in the UF-MSC game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\sf UF-MSC}_{\Pi, \mathbb{B}, \mathcal{A}} := \Pr[{\sf UF-MSC}_{\Pi, \mathbb{B}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A'}} \Pr[{\sf UF-MSC'}_{\Pi, \mathbb{B}}(\mathcal{A'}) \to 1].
\]

An authentication scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ is called \emph{unforgeable against malicious scanner} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\sf UF-MSC}_{\Pi, \mathbb{B}, \mathcal{A}} = \negl.
\]

Note that in the Device-of-Domain model, the probe oracle ${\sf Probe}({\sf psk}, \cdot)$ is assumed to be public, so the scheme is never unforgeable against a malicious scanner who has access to the {\sf User}'s biometric data ($\mathcal{O}_{\mathcal{B}}$). Therefore, we only consider {\sf UF-MSC} security in the Device-of-User model. 


%-------------------

\subsection{Unforgeability against Malicious Device (UF-MDV)}
\label{sec:uf-mdv_game}

In the game of Unforgeability against Malicious Device (UF-MDV), we model the ability of a malicious {\sf Device} who has access to {\sf Server}'s database of registered enrollments and tries to impersonate the user. The adversary $\mathcal{A}$ is given the enrollment message $\mathbf{c_x}$, keys ${\sf esk}, {\sf psk}$ (only {\sf psk} if it is in Device-of-Domain model), and oracle $\mathcal{O}_{\sf auth}^q$ and tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game is defined in Algorithm \ref{alg:uf-mdv_game}.


\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.45\linewidth}
	\begin{algorithm}[H]
	\caption{${\sf UF-MDV}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:uf-mdv_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State ${\sf esk}, {\sf psk}, {\sf csk} \gets {\sf Setup}(1^\lambda)$

		\State $\mathbf{x} \gets {\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets {\sf Enroll}({\sf esk}, \mathbf{x})$

		\State In Device-of-User model:
		
		\State \hspace{\algorithmicindent} ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O}_{\sf auth}^q } ({\sf esk}, {\sf psk}, \mathbf{c_x} )$

		\State In Device-of-Domain model:
		
		\State \hspace{\algorithmicindent} ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O}_{\sf auth}^q } ( {\sf psk}, \mathbf{c_x} )$

		\State $s \gets {\sf Compare}( {\sf csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return ${\sf Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	\begin{minipage}[t]{0.45\linewidth}
	\begin{algorithm}[H]
	\caption{${\sf UF-MDV}^\prime_{\Pi, \mathbb{B}}(\mathcal{A'})$}
	\label{alg:plain_uf-mdv_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State ${\sf esk}, {\sf psk}, {\sf csk} \gets {\sf Setup}(1^\lambda)$

		\State $\mathbf{x} \gets {\sf encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets {\sf Enroll}({\sf esk}, \mathbf{x})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A'}^{\mathcal{O}_{\sf auth}^q}()$

		\State $s \gets {\sf Compare}( {\sf csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return ${\sf Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\caption{The UF-MDV Game (Left) and Plain UF-MDV Game (Right)}
\label{fig:uf-mdv_game}
\end{figure}

To consider potential false positives of biometrics match, we consider the plain UF-MDV game in Algorithm \ref{alg:plain_uf-mdv_game}, in which the adversary does not have any knowledge about the template.

We define the advantage of an adversary $\mathcal{A}$ in the UF-MDV game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\sf UF-MDV}_{\Pi, \mathbb{B}, \mathcal{A}} := \Pr[{\sf UF-MDV}_{\Pi, \mathbb{B}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A'}} \Pr[{\sf UF-MDV'}_{\Pi, \mathbb{B}}(\mathcal{A'}) \to 1].
\]

An authentication scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ is called \emph{unforgeable against malicious device} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\sf UF-MDV}_{\Pi, \mathbb{B}, \mathcal{A}} = \negl.
\]
%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\nocite{*}
\printbibliography


\end{document}
