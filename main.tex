%%%%%%%%%%%%%%%%%%%%

% Semester Project Fall 2024 for EPFL
% Author: Keng-Yu Chen

%%%%%%%%%%%%%%%%%%%%

\input{header.tex}


\begin{document}

%% Title
\maketitle

%-------------------

%% Header and Foot
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Semester Project}
\fancyhead[C]{Biometric Authentication}
\fancyhead[R]{Keng-Yu Chen}
\fancyfoot[C]{\thepage}

%-------------------

This report formalizes the biometric authentication scheme, including its structure, usage, and security analysis with a security game model.

%-------------------

\section{Preliminaries}
\label{sec:preliminaries}

In this report, we assume

\begin{itemize}
	
	\item $\lambda$ is the security parameter.

	\item $[m]$ denotes the set of integers $\{1, 2, \cdots, m\}$.

	\item $\Z_q$ is the finite field modulo a prime number $q$.

	\item A function $f(n)$ is called \emph{negligible} iff for any integer $c$, $f(n) < \frac{1}{n^c}$ for all sufficiently large $n$. We write it as $f(n) = \negl$, and we may also use $\negl$ to represent an arbitrary negligible function.
	
	\item $\poly$ is the class of polynomial funcions. We may also use $\poly$ to represent an arbitrary polynomial function.
	
	\item We write sampling a value $r$ from a distribution $\mathcal{D}$ as $r \getsdollar \mathcal{D}$. If $S$ is a finite set, then $r \getsdollar S$ means sampling $r$ uniformly from $S$.

	\item The distribution $\mathcal{D}^t$ denotes $t$ identical and independent distributions of $\mathcal{D}$.

	\item A PPT algorithm denotes a probabilistic polynomial time algorithm. Unless otherwise specified, all algorithms run in PPT.

\end{itemize}

We introduce three types of inner product functional encryption schemes: function hiding functional encryption, two-input functional encryption, and two-client functional encryption. We will instantiate our biometric authentication scheme using these primitives.

\begin{definition}[Function Hiding Inner Product Functional Encryption]
\label{def:fh-IPFE}
	A \emph{function hiding inner product functional encryption} (fh-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$: It outputs the public parameter $\textsf{pp}$ and the master secret key $\textsf{msk}$.
	
		\item $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$: It generates the functional decryption key $f_\mathbf{x}$ for an input vector $\mathbf{x} \in \mathbb{F}^k$. 
	
		\item $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$: It encrypts the input vector $\mathbf{y} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_y}$. 
	
		\item $\textsf{FE.Dec}(\textsf{pp}, f_\mathbf{x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The fh-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$ and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}( \textsf{pp}, \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}), \textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) ) = \mathbf{x} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using an fh-IPFE scheme is given in Section \ref{sec:fh-IPFE-instantiation}.

\begin{definition}[Two-Input Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2i-IPFE}
	A \emph{two-input inner product functional encryption} (2i-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2i-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, and $\mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have

	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2i-IPFE is given in Section \ref{sec:2i-IPFE-instantiation}.

\begin{definition}[Two-Client Inner Product Functional Encryption (adapted from \cite{cryptoeprint:2022/441})]
\label{def:2c-IPFE}
	A \emph{two-client inner product functional encryption} (2c-IPFE) scheme $\sf FE$ for a field $\mathbb{F}$ and input length $k$ is composed of PPT algorithms $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, $\textsf{FE.Enc}$, and $\textsf{FE.Dec}$:

	\begin{itemize}
	
		\item $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$: It outputs a secret key $\textsf{sk}$ and two encryption keys $\textsf{ek}_1, \textsf{ek}_2$.
	
		\item $\textsf{FE.KeyGen}(\textsf{sk}, \mathbf{A}) \to \textsf{dk}_\mathbf{A}$: It generates the functional decryption key $\textsf{dk}_\mathbf{A}$ for a diagonal matrix $\mathbf{A} \in \mathbb{F}^{k \times k}$,  
	
		\item $\textsf{FE.Enc}(\ell, \textsf{ek}_i, \mathbf{x}) \to \mathbf{c_x}$: Given a label $\ell$ and an encryption key, either $\textsf{ek}_1$ or $\textsf{ek}_2$, it encrypts the input vector $\mathbf{x} \in \mathbb{F}^k$ to the ciphertext $\mathbf{c_x}$. 
	
		\item $\textsf{FE.Dec}(\textsf{dk}_\mathbf{A}, \mathbf{c_x}, \mathbf{c_y}) \to z$: It outputs a value $z \in \mathbb{F}$.
	
	\end{itemize}
	
	\noindent Correctness: The 2c-IPFE scheme \textsf{FE} is \emph{correct} if $\forall (\textsf{sk}, \textsf{ek}_1, \textsf{ek}_2) \gets \textsf{FE.Setup}(1^\lambda), \mathbf{A} \in \mathbb{F}^{k \times k}$, label $\ell$, and $ \mathbf{x}, \mathbf{y} \in \mathbb{F}^k$, we have
	\[
		\textsf{FE.Dec}(\textsf{FE.KeyGen}(\textsf{sk},  \mathbf{A}), \textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}), \textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) ) = \mathbf{x} \mathbf{A} \mathbf{y}^T \in \mathbb{F}.
	\]

\end{definition}

Instantiation using a 2c-IPFE is given in Section \ref{sec:2c-IPFE-instantiation}.

We also consider an instantiation using a relational hash scheme.

\begin{definition}[Relational Hash (adapted from \cite{cryptoeprint:2014/394})]
\label{def:rh}
	Let $R_\lambda$ be a relation over sets $X_\lambda, Y_\lambda$, and $ Z_\lambda$. A \emph{relational hash} scheme \textsf{RH} for $R_\lambda$ consists of PPT algorithms \textsf{RH.KeyGen}, $\textsf{RH.HASH}_1$, $\textsf{RH.HASH}_2$, and \textsf{RH.Verify}:
	
	\begin{itemize}
	
		\item $\textsf{RH.KeyGen}(1^\lambda) \to \textsf{pk}$: It outputs a public hash key \textsf{pk}.  
			
		\item $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$: Given a hash key \textsf{pk} and $\mathbf{x} \in X_\lambda$, it outputs a hash $\mathbf{h_x}$.

		\item $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$: Given a hash key \textsf{pk} and $\mathbf{y} \in Y_\lambda$, it outputs a hash $\mathbf{h_y}$.

		\item $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}) \to r \in \{0, 1\}$: Given a hash key \textsf{pk}, two hashes $\mathbf{h_x}$ and $\mathbf{h_y}$, and $\mathbf{z} \in Z_\lambda$, it verifies whether the relation among $\mathbf{x}, \mathbf{y}$ and $\mathbf{z}$ holds.

	\end{itemize}

	\noindent Correctness: The relational hash scheme \textsf{RH} is \emph{correct} if $\forall \mathbf{x}, \mathbf{y}, \mathbf{z} \in X_\lambda \times Y_\lambda \times Z_\lambda$,
	\[
		\Pr \left [
			\begin{cases} 
				 \textsf{pk} \gets \textsf{RH.KeyGen}(1^\lambda) \\
				 \mathbf{h_x} \gets \textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \\
				 \mathbf{h_y} \gets \textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y})
			\end{cases} :
			\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}, \mathbf{z}) = R(\mathbf{x}, \mathbf{y}, \mathbf{z})
			\right ] = 1 - \negl.
	\]
\end{definition}

Instantiation using a relational hash is given in Section \ref{sec:rh-instantiation}.


%-------------------


\section{Formalization}
\label{sec:formalization}


In general, an authentication shceme $\Pi$ associated with a family of biometric distributions $\mathbb{B}$ is composed of the following algorithms.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda) \to \textsf{esk}, \textsf{psk}, \textsf{csk}$: It outputs the enrollment secret key $\textsf{esk}$, probe secret key $\textsf{psk}$, and compare secret key $\sf csk$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{x}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{x}$, the input format for enrollment. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x}) \to \mathbf{c_x}$: It outputs the enrollment message $\mathbf{c_x}$ from $\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}() \to \mathbf{y}$: Given an oracle $\mathcal{O}_{\mathcal{B}}$, which samples biometric data from the distribution $\mathcal{B} \in \mathbb{B}$, it encodes biometric samples as $\mathbf{y}$, the input format for probe.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y}) \to \mathbf{c_y}$: It outputs the probe message $\mathbf{c_y}$ from $\mathbf{y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)} \to s$: It compares the enrollment message $\mathbf{c_x}$ and probe message $\mathbf{c_y}$ and outputs a score $s$.

	\item $\textsf{Verify}(s) \to r \in \{0,1\}$: It is a deterministic algorithm that reads the comparison score $s$ and determines whether this is a successful authentication ($r = 1$) or not ($r = 0$).

\end{itemize}

\noindent 
We discuss two usage models that employs the authentication scheme $\Pi$.


%-------------------


\subsection{Usage Model – Device-of-User}
\label{sec:dou_model}

In the model described in Figure \ref{fig:model_dou_overview} (an overview), Figure \ref{fig:model_dou_enrollment} (on enrollment), and Figure \ref{fig:model_dou_auth} (on authentication), users authenticate themselves to a server through their own devices and biometric scanners that are shared among different users.
A key distribution service distributes keys for them. In practice, this model applies to the situation when the users access an online service run by the server.

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$. 

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Device}: A device belonging to the user. In practice, it can be a desktop or a mobile phone. It processes the \textsf{Enroll} and \textsf{Probe} functions for $\textsf{User}$ with keys \textsf{esk} and \textsf{psk}. It queries $\mathcal{O}_{\mathcal{B}}$ for biometric data through the \textsf{Scanner}.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to $\textsf{Device}$ and $\textsf{Server}$.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}

The Device-of-User model, when instantiated by an fh-IPFE scheme (Section \ref{sec:fh-IPFE-instantiation}), is analogous to the use case presented in \cite{cryptoeprint:2023/481}.
In their model, a user possesses a personal device, such as a smartphone or laptop, and a secure hardware device that runs an initial setup and stores all the keys, which corresponds to our \textsf{KDS}.
On enrollemnt and authentication, the user inputs biometric templates onto the device, which corresponds to our \textsf{Scanner}.
Subsequently, the device transmits the template to the secure hardware for the enrollment or probing processes, which are equivalent to our \textsf{Device}.
In addition, they incorporate a two-factor authentication mechanism.
The secure hardware also executes a digital signature scheme and sign the probe message on authentication.


\input{tikz/dou_model.tex}

%-------------------

\subsection{Usage Model – Device-of-Domain}
\label{sec:dod_model}

In the model described in Figure \ref{fig:model_dod_overview} (an overview), Figure \ref{fig:model_dod_enrollment} (on enrollment), and Figure \ref{fig:model_dod_auth} (on authentication), users first enroll themselves at an enrollment station and then authenticate themselves to a server through devices that belong to a domain.
A key distribution service distributes enrollment keys to the enrollment station, probe keys to the domain, and comparison keys to the server. In practice, a domain can be a department in an organization, and this models applies to the situation when a user wants to access a public service of a department, such as a restricted area or instruments. 

\begin{itemize}

	\item \textsf{User}: The user who enrolls its biometric data at an enrollment station and authenticates itself to the server. We assume the user's biometric distribution is $\mathcal{B} \in \mathbb{B}$.
	
	\item \textsf{Domain}: A domain that owns several devices, all of which share one enrollment key $\textsf{esk}$, one probe key $\textsf{psk}$ and one comparison key $\textsf{csk}$. Only the probe key is stored at each device of a domain. The enrollment key is stored at the enrollment station, and the comparison key is stored at the server. In practice, a domain can be a department, and users enroll and authenticate themselves before accessing a restricted service of this department.

	\item \textsf{Scanner}: A machine to extract the user's biometric data by querying the oracle $\mathcal{O}_{\mathcal{B}}$.
	
	\item \textsf{Station}: An enrollment station responsible for collecting the user's biometric data to enroll them for a domain on the server.

	\item \textsf{Device}: A device belonging to a domain. In practice, it can be a device checking identities for a restricted area or an instrument. It owns a probe key $\sf psk$ and processes the $\sf Probe$ function for enrolled users of this domain.
	
	\item \textsf{KDS}: A key distribution service. It runs $\textsf{Setup}$ to generate keys and distribute them to \textsf{Station}, \textsf{Domain}, and \textsf{Server}.
		
	\item \textsf{Server}: The server responsible for authenticating the user. It stores the comparison key \textsf{csk} for each domain and the user's enrollment message $\mathbf{c_x}$. On authentication, it compares the probe message with the registered enrollment message and returns the result.  

\end{itemize}


%-------------------

\input{tikz/dod_model.tex}

\pagebreak

%-------------------

\subsection{Instantiation with an fh-IPFE Scheme}
\label{sec:fh-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be an fh-IPFE scheme we defined in Definition \ref{def:fh-IPFE}. Following \cite{cryptoeprint:2023/481}, we can instantiate a biometric authentication scheme using $\textsf{FE}$ with the distance metric the Euclidean distance. Let the biometric distribution $\mathcal{B} \subseteq [m]^k$, and let the associated field of $\textsf{FE}$ be $\mathbb{Z}_q$ where $q$ is a prime number larger than the maximum possible Euclidean distance $m^2 \cdot k$. The scheme is instantiated as follows.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{msk}, \textsf{pp}$ and outputs $\textsf{esk} \gets (\textsf{msk}, \textsf{pp})$, $\textsf{psk} \gets (\textsf{msk}, \textsf{pp})$ and $\textsf{csk} \gets \textsf{pp}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b} = (b_1, b_2, \cdots, b_k)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{x} = (x_1, x_2, \cdots, x_{k+2}) = (b_1, b_2, \cdots, b_k, 1, \|\mathbf{b}\|^2)$. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}) \to f_\mathbf{x}$ and outputs $\mathbf{c_x} \gets f_\mathbf{x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime = (b_1^\prime, b_2^\prime, \cdots, b_k^\prime)$ sampled from $\mathcal{O}_{\mathcal{B}}$, the function encodes it as $\mathbf{y} = (y_1, y_2, \cdots, y_{k+2}) = (-2b_1^\prime, -2b_2^\prime, \cdots, -2b_k^\prime, \|\mathbf{b}^\prime\|^2, 1)$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{y}^T = \sum_{i=1}^k -2b_ib_i^\prime + \|\mathbf{b}\|^2 + \|\mathbf{b}^\prime\|^2 = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]

which is the square of the Euclidean distance between two templates $\mathbf{b}$ and $\mathbf{b}^\prime$. Therefore, if two templates $\mathbf{b}$ and $\mathbf{b}^\prime$ are close enough such that $\|\mathbf{b} - \mathbf{b}^\prime\| < \tau$, the scheme results in $r = 1$, a successful authentication.


Instantiated with an fh-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is public, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are the same. Anyone with access to the enrollment message $\mathbf{c_x}$ and either one of $\textsf{esk}$, $\textsf{psk}$, or a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot )$ can probe some $\mathbf{y}^{\prime} \in \mathbf{F}^{k+2}$ and find $\mathbf{x} {\mathbf{y}^\prime}^T$ to get partial or full information about $\mathbf{x}$. Even if the adversary can only sample random ciphertexts $\mathbf{c_{y}}$ without knowing $\mathbf{y}$, if the field size $q$ is not large enough, one can find a forged $\mathbf{c_{y^*}}$ such that $\mathbf{x}\mathbf{y^*}^T < \tau$ to impersonate the user by sampling many times offline.

Therefore, \textsf{Server} must store $\mathbf{c_x}$ securely, to avoid such an attack from an adversary who can access the probe oracle; \textsf{Device} must protect its probe function, to avoid such an attack from a malicious \textsf{Server}. 

In the Device-of-Domain model, we assume the probe oracle is public, just as everyone can try accessing a public service. A malicious \textsf{Station} or \textsf{Server}, who has the enrollment message $\mathbf{c_x}$, can utilize this attack to retrieve information about \textsf{User}.


%-------------------


\subsection{Instantiation with a 2i-IPFE Scheme}
\label{sec:2i-IPFE-instantiation}

Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2i-IPFE scheme we defined in Definition \ref{def:2i-IPFE}. Following the scheme in Section \ref{sec:fh-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $ \textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. It outputs $\textsf{esk} \gets \textsf{ek}_1$, $\textsf{psk} \gets \textsf{ek}_2$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:fh-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \mathbf{x} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:fh-IPFE-instantiation}


Unlike the previous scheme, instantiated with a 2i-IPFE scheme in this way, the comparison secret key $\textsf{csk}$ is now secret, and the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are distinct. Without $\textsf{csk}$, one cannot compare an enrollment message $\mathbf{c_x}$ and a probe message $\mathbf{c_y}$. We can also transmit $\mathbf{c_x}$ in a public channel and store it in a public storage, under necessary security requirements of the 2i-IPFE scheme, such as indistinguishability of $\mathbf{c_x}$.

In the Device-of-Domain model, the indistinguishability of $\mathbf{c_x}$ is against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$. If \textsf{Server} is malicious, then it can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ enrolled by different samples. Therefore, we must limit the adversary's ability. For example, we can require the adversary to distinguish biometric vectors sampled from distributions in a pre-defined pool, and the adversary can only probe vectors randomly sampled from a distribution in the pool. We can also limit the rate of the probe oracle.

%-------------------

\subsection{Instantiation with a 2c-IPFE Scheme}
\label{sec:2c-IPFE-instantiation}

Note that if labels remain constant, a 2c-IPFE scheme is reduced to a 2i-IPFE scheme. Therefore, we can consider utilizing the label to represent each domain in the Device-of-Domain model. Let $\textsf{FE} = (\textsf{FE.Setup}, \textsf{FE.KeyGen}, \textsf{FE.Enc}, \textsf{FE.Dec})$ be a 2c-IPFE scheme we defined in Definition \ref{def:2c-IPFE}. Following the scheme in Section \ref{sec:2i-IPFE-instantiation}, we can instantiate a biometric authentication scheme using $\textsf{FE}$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{FE.Setup}(1^\lambda) \to \textsf{sk}, \textsf{ek}_1, \textsf{ek}_2$, $\textsf{FE.KeyGen}(sk, \mathbf{I}_{k+2}) \to \textsf{dk}_{\mathbf{I}} $, where $\mathbf{I}_{k+2}$ is an identity matrix of size $(k+2) \times (k+2)$. For keys used for \textsf{Domain} $\ell$, it outputs $\textsf{esk} \gets (\ell, \textsf{ek}_1)$, $\textsf{psk} \gets (\ell, \textsf{ek}_2)$, and $\textsf{csk} \gets \textsf{dk}_{\mathbf{I}}$.

	Note that when the previous 2i-IPFE-based scheme in Section \ref{sec:2i-IPFE-instantiation} is applied to a Device-of-Domain model, we assume that $\textsf{Setup}$ is run once for each domain to generate different $\textsf{esk}, \textsf{psk}, \textsf{csk}$. In the scheme in this section, however, $\textsf{Setup}$ is run only once for all the domains, and each domain shares the same $\textsf{csk}$ and the same $\textsf{esk}, \textsf{psk}$ except different labels.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}(), \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: The same as the scheme in \ref{sec:2i-IPFE-instantiation}. 

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_1, \mathbf{x}) \to \mathbf{c_x}$ and outputs $\mathbf{c_x}$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{FE.Enc}(\ell, \textsf{ek}_2, \mathbf{y}) \to \mathbf{c_y}$ and outputs $\mathbf{c_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: If $\sqrt{s} < \tau$, a pre-defined threshold for comparing the closeness of two templates, then it outputs $r = 1$; otherwise, it outputs $r = 0$.

\end{itemize}

By the correctness of the functional encryption scheme $\sf FE$, if the labels of $\mathbf{c_x}$ and $\mathbf{c_y}$ are the same (they are of the same domain), we have
\[
	s = \textsf{FE.Dec}(\textsf{dk}_{\mathbf{I}}, \mathbf{c_x}, \mathbf{c_y}) =  \mathbf{x} \mathbf{I}_{k+2} \mathbf{y}^T = \| \mathbf{b} - \mathbf{b}^\prime \|^2.
\]
just as the scheme in Section \ref{sec:2i-IPFE-instantiation}

When the Device-of-Domain model is instantiated with a 2c-IPFE scheme in this way, the enrollment secret key $\textsf{esk}$ and probe secret key $\textsf{psk}$ are now shared among all the devices, regardless of their domains. Therefore, to let a malicious or broken \textsf{Domain} not threaten other honest ones, one needs to make sure given $\textsf{esk}$ or $\textsf{psk}$, $\mathbf{c_x}$ still does not leak information about $\mathbf{x}$. This is different from the scheme in Section \ref{sec:2i-IPFE-instantiation}, where we only need seurity against an adversary who has a probe oracle $\textsf{Probe}(\textsf{psk}, \cdot)$.

If \textsf{Server} and \textsf{Domain} are both malicious, then the adversary can use $\textsf{csk}$ to distinguish $\mathbf{c_x}$ and even recover $\mathbf{x}$. Therefore, we assume at most one party of them can be malicious at the same time. Note that this is the same as the 2i-IPFE-based scheme, where only one of \textsf{Server} and \textsf{Domain} can be malicious.

%-------------------

\subsection{Instantiation with a Relational Hash Scheme}
\label{sec:rh-instantiation}

Let $\textsf{RH} = (\textsf{RH.KeyGen}, \textsf{RH.Hash}_1, \textsf{RH.Hash}_2, \textsf{RH.Verify})$ be a relational hash scheme we defined in Definition \ref{def:rh} for the relation $R$ of Hamming distance proximity parametrized by a constant $\tau$.
\[
	R = \{ (\mathbf{x}, \mathbf{y}) \mid \textsf{HD}(\mathbf{x}, \mathbf{y}) \leq \tau \wedge \mathbf{x}, \mathbf{y} \in \{0,1\}^k \}
\]
Note that here we ignore the third parameter $Z$.
Following \cite{cryptoeprint:2023/481} and \cite{cryptoeprint:2014/394}, we can instantiate a biometric authentication scheme using $\textsf{RH}$.  Let the biometric distribution $\mathcal{B} \subseteq \{0,1\}^k$.

\begin{itemize}

	\item $\textsf{Setup}(1^\lambda)$: It calls $\textsf{RH.Setup}(1^\lambda) \to \textsf{pk}$ and outputs $\textsf{esk} \gets \textsf{pk}$, $\textsf{psk} \gets \textsf{pk}$, and $\textsf{csk} \gets \textsf{pk}$.

	\item $\textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}$ sampled from $\mathcal{O}_\mathcal{B}$, it direclty outputs $\mathbf{x} \gets \mathbf{b}$.

	\item $\textsf{Enroll}(\textsf{esk}, \mathbf{x})$: It calls $\textsf{RH.Hash}_1(\textsf{pk}, \mathbf{x}) \to \mathbf{h_x}$ and outputs $\mathbf{c_x} \gets \mathbf{h_x}$.

	\item $\textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$: For a template vector $\mathbf{b}^\prime$ sampled from $\mathcal{O}_\mathcal{B}$, it directy outputs $\mathbf{y} \gets \mathbf{b}^\prime$.

	\item $\textsf{Probe}(\textsf{psk}, \mathbf{y})$: It calls $\textsf{RH.Hash}_2(\textsf{pk}, \mathbf{y}) \to \mathbf{h_y}$ and outputs $\mathbf{c_y} \gets \mathbf{h_y}$.

	\item $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{c_y)}$: It calls $\textsf{RH.Verify}(\textsf{pk}, \mathbf{h_x}, \mathbf{h_y}) \to s$ and outputs the value $s$.

	\item $\textsf{Verify}(s)$: It direclty returns $r \gets s$.

\end{itemize}

By the correctness of the relational hash scheme $\textsf{RH}$, we have (except for a negligible probability),
\[
	r = 1 \Leftrightarrow (\mathbf{x}, \mathbf{y}) \in R \Leftrightarrow \textsf{HD}(\mathbf{b}, \mathbf{b}^\prime) \leq \tau
\]


%-------------------


\section{Security Games}
\label{sec:security_game}

To rigorously analyze the security of an authentication scheme, we simulate biometric distributions of users by assuming the existence of a family $\mathbb{B}$ of distributions. We require that all distributions in $\mathbb{B}$ are efficiently samplable and has an excessively large size for a PPT adversary to enumerate. We then provide interfaces for all algorithms to interact with $\mathbb{B}$.

\begin{itemize}

	\item $\textsf{BioSamp}()$: Generate a random distribution $\mathcal{B}$ of $\mathbb{B}$. By this we mean providing either parameters of an efficiently samplable distribution or a PPT algorithm as the sampler. For simplicity, we write $\mathcal{B} \gets \textsf{BioSamp}()$ as $\mathcal{B} \getsdollar \mathbb{B}$.
	
	\item $\textsf{BioDelete}(\mathcal{B})$: Delete $\mathcal{B}$ from $\mathbb{B}$. Consequently, no further access to $\textsf{BioSamp}$ can derive $\mathcal{B}$. For simplicity, we write $\textsf{BioDelete}(\mathcal{B})$ as $\mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$.

	\item $\mathcal{O}_\textsf{samp}(\cdot)$: On input an index $i$,
	\begin{itemize}
		\item If $i$ was not queried before, it first samples a biometric distribution $\mathcal{B}_i \in \mathbb{B}$ by $\textsf{BioSamp}$ and then outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}_i$.
		\item If $i$ has been queried before, it outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}_i$.
	\end{itemize}
\end{itemize}

% Comment
\iffalse

In Table \ref{table:security_games}, we list a summary of the adversary in each game.

\begin{table}[htp]
\centering
	\begin{tabular}{l l c l@{\hspace{15pt}} l}
	\toprule

		\multicolumn{2}{c}{ \multirow{2}{*}{\textbf{Games}} } & \multirow{2}{*}{\textbf{Goals}} & \multicolumn{2}{c}{\textbf{Knowledge and Oracles}} \\

		\cmidrule{4-5}
		
		 & & & \makecell[c]{Device-of-User} & \makecell[c]{Device-of-Domain} \\

	\midrule
	
		\textsf{UF-MSC} &(Section \ref{sec:uf-msc_game}) & Forge a probe & $\mathbf{c_x}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{auth}^q$ & $\mathbf{c_x}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]

		\textsf{UF-MDV} &(Section \ref{sec:uf-mdv_game}) & Forge a probe & $\textsf{esk}, \textsf{psk}, \mathbf{c_x},\mathcal{O}_\textsf{auth}^q$ & $\textsf{psk}, \mathbf{c_x},\mathcal{O}_\textsf{auth}^q$ \\ [5pt]

		\textsf{UF-MDM} &(Section \ref{sec:uf-mdm_game}) & Forge a probe & \makecell[c]{-} & $\mathbf{c_x}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_{\textsf{Probe}}^\prime, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]
		
		\textsf{UF-MST} &(Section \ref{sec:uf-mst_game}) & Forge a probe & \makecell[c]{-} & $ \textsf{esk}, \mathbf{c_x}, \mathcal{O}_{\textsf{Probe}}, \mathcal{O}_{\textsf{Enroll}}^\prime, \mathcal{O}_\textsf{auth}^q$ \\ [5pt]
		
		\textsf{IND-MSV} &(Section \ref{sec:ind-msv_game}) & Identify \textsf{User} 
			& \makecell[l]{ $\textsf{csk}, \mathbf{c_x}, \{\mathbf{c_y}\}_{i=1}^t$, \\ $\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}$ } 
			& \makecell[l]{ $ \textsf{csk}, \mathbf{c_x}, \{\mathbf{c_y}\}_{i=1}^t$, \\ $\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}, \mathcal{O}_{\textsf{Probe}}^{\textsf{samp}} $ } \\

	\bottomrule
	\end{tabular}
	\caption{Summary of Adversaries in Security Games}
	\label{table:security_games}

\end{table}

\fi
%-------------------

\newpage

%-------------------

\subsection{Unforgeability against Leakage of Biometrics (UF-LoB)}
\label{sec:uf-lob_game}

In the game of Unforgeability against Leakage of Biometrics, we model the ability of an adversary who has access to \textsf{User}'s biometrics and tries to impersonate \textsf{User}. The adversary $\mathcal{A}$ is given the enrollment message $\mathbf{c_x}$, oracles $\mathcal{O}_\mathcal{B}$ and $\mathcal{O}_\textsf{auth}^q$, and auxiliary information \textsf{option}, which depends on our threat model. The adversary tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game \textsf{UF-LoB} is defined in Algorithm \ref{alg:uf-lob_game}.

\begin{figure}[h]
\centering
	\begin{minipage}[t]{0.6\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\textsf{UF-LoB}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:uf-lob_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$
		
		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\mathcal{B}}, \mathcal{O}_\textsf{auth}^q } ( \mathbf{c_x}, \textsf{option} )$

		\If{ $\mathbf{\tilde{z}}$ equals to any output of $\mathcal{O}_\textsf{Probe}$ }
		
		\State \Return $\bot$
		
		\EndIf

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:uf-lob_game}
\end{figure}


The given oracle is defined as follows:

\begin{itemize}
	\item $\mathcal{O}_{\mathcal{B}}$: It outputs a biometric sample $\mathbf{b} \getsdollar \mathcal{B}$.

	\item $\mathcal{O}_\textsf{auth}^{q}(\textsf{csk}, \cdot, \cdot)$: This is a resource-limited oracle. If it has been queried over $q$ times in total, it aborts. Otherwise, on input $\mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}$, it outputs $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}} ) )$.
\end{itemize}

The auxiliary information \textsf{option} can be nothing or include $\textsf{esk}$ or the following oracles:

\begin{itemize}

	\item $\mathcal{O}_\textsf{Enroll}(\textsf{esk}, \cdot)$: On input $\mathbf{x}^\prime$, it outputs the enrollment message $\textsf{Enroll}(\textsf{esk}, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}(\textsf{psk}, \cdot)$: On input $\mathbf{y}^\prime$, it outputs the probe message $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime)$. 
\end{itemize}

To avoid trivial attacks, if the probe oracle $\mathcal{O}_\textsf{Probe}$ is given, the adversary is asked to return some $\mathbf{\tilde{z}}$ that is not returned by the probe oracle.

To consider potential false positives of biometrics match, we consider the plain $\textsf{UF}$ game in Algorithm \ref{alg:uf_game}, in which the adversary has only public information.

\begin{figure}[H]
\centering
	\begin{minipage}[t]{0.5\linewidth}
	\begin{algorithm}[H]
	\caption{$\textsf{UF}_{\Pi, \mathbb{B}}(\mathcal{A}^\prime)$}
	\label{alg:uf_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\prime \mathcal{O}_\textsf{samp}, \mathcal{O}_\textsf{log}^q }()$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
\label{fig:uf_game}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}_\textsf{log}^{q}(\textsf{csk}, \mathbf{c_x}, \cdot)$: This is a resource-limited oracle. If it has been queried over $q$ times in total, it aborts. Otherwise, on input $\mathbf{z}$, it outputs $\textsf{Verify}(\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \mathbf{z} ) )$.

\end{itemize}

We define the advantage of an adversary $\mathcal{A}$ with $\textsf{option}$ in the \textsf{UF-LoB} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{UF-LoB}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[{\textsf{UF-LoB}}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1].
\]

An authentication scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ is called \emph{\textsf{option}-unforgeable against leakage of biometrics (UF-LoB)} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{UF-LoB}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} = \negl.
\]

Note that if $\textsf{csk}$ is an empty or public string, then the scheme cannot achieve UF-LoB security when the false positive rate is not negligible, as the adversary can run the $\textsf{Compare}(\textsf{csk}, \mathbf{c_x}, \cdot)$ over $q$ times to boost the false positive rates.

For the rest of this report, if the scheme, the family distribution, and the auxiliary information $\textsf{option}$ are clear from context, we omit the subscript and write the game as $\textsf{UF-LoB}(\mathcal{A})$. This abbreviation also holds for all other games.


%-------------------


\subsection{Unforgeability against Leakage of Keys (UF-LoK)}
\label{sec:uf-lok_game}

In the game of Unforgeability against Leakage of Keys, we model the ability of an adversary who has access to keys and tries to impersonate \textsf{User}. The adversary $\mathcal{A}$ is given the enrollment message $\mathbf{c_x}$, oracles $\mathcal{O}_\textsf{auth}^q$, and auxiliary information \textsf{option}, which depends on our threat model. The adversary tries to find a valid probe message $\mathbf{\tilde{z}}$. The whole game \textsf{UF-LoK} is defined in Algorithm \ref{alg:uf-lok_game}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.8\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\textsf{UF-LoK}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:uf-lok_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\For{$i = 1$ to $L$}

			\State $\textsf{esk}_i, \textsf{psk}_i, \textsf{csk}_i \gets \textsf{Setup}(1^\lambda)$ \Comment{Keys for Domain $i \in [L]$}
		
		\EndFor

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}_1, \mathbf{x})$
		
		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{ \mathcal{O}_{\textsf{samp}}, \mathcal{O}_\textsf{auth}^q } ( \mathbf{c_x}, \textsf{option} )$

		\State $s \gets \textsf{Compare}( \textsf{csk}_1, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:uf-lok_game}
\end{figure}


The auxiliary information \textsf{option} can be nothing or include $\textsf{esk}_1$, $\mathcal{O}_\textsf{Enroll}(\textsf{esk}_1, \cdot)$, $\textsf{psk}_1$, $\mathcal{O}_\textsf{Probe}(\textsf{psk}_1, \cdot)$, $\textsf{csk}_1$, or the following oracles.

\begin{itemize}
	
	\item $\mathcal{O}_\textsf{Enroll}^{(i)}(\textsf{esk}_i, \cdot)$: On input $\mathbf{x}^\prime$, it outputs the enrollment message $\textsf{Enroll}(\textsf{esk}_i, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}^{(i)}(\textsf{psk}_i, \cdot)$: On input $\mathbf{y}^\prime$, it outputs the probe message $\textsf{Probe}(\textsf{psk}_i, \mathbf{y}^\prime)$. 
	
	\item $\mathcal{O}_\textsf{Enroll}^\prime (\cdot)$: On input $\textsf{esk}^\prime$, it first samples $\mathbf{x}^\prime \getsdollar \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Enroll}(\textsf{esk}^\prime, \mathbf{x}^\prime)$.

	\item $\mathcal{O}_\textsf{Probe}^\prime (\cdot)$: On input $\textsf{psk}^\prime$, it first samples $\mathbf{y}^\prime \getsdollar \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}}}()$ and outputs $\textsf{Probe}(\textsf{psk}^\prime, \mathbf{y}^\prime)$. This oracle and $\textsf{psk}_1$ should not be given at the same time. 

\end{itemize}

To consider potential false positives of biometrics match, we also consider the plain $\textsf{UF}$ game in Algorithm \ref{alg:uf_game}, in which the adversary has only public information.

We define the advantage of an adversary $\mathcal{A}$ with $\textsf{option}$ in the \textsf{UF-LoK} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{UF-LoK}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} := \Pr[{\textsf{UF-LoK}}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] -
	\sup_{\text{PPT } \mathcal{A}^\prime} \Pr[\textsf{UF}_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1].
\]

An authentication scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ is called \emph{\textsf{option}-unforgeable against leakage of keys (UF-LoK)} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{UF-LoK}}_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}} = \negl.
\]


%-------------------

\subsection{Indistinguishable against Malicious Server (IND-MSV)}
\label{sec:ind-msv_game}

In the game of Indistinguishable against Malicious Server, we model the ability of a malicious \textsf{Server} who tries to identify the user. The adversary $\mathcal{A}$ is given oracles to two biometric distributions $\mathcal{B}^{(0)}, \mathcal{B}^{(1)}$, the comparison key $\textsf{csk}$, an enrollment message $\mathbf{c_x}$, and a list of $t$ probe messages $\{ \mathbf{c_y}^{(i)} \}_{i=1}^t$ . It tries to guess from either $\mathcal{B}^{(0)}$ or $ \mathcal{B}^{(1)}$ these messages are generated. The whole game is defined in Algorithm \ref{alg:ind-msv_game}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.6\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{IND-MSV}_{\Pi, \mathbb{B}}(\mathcal{A})$}
	\label{alg:ind-msv_game}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$

		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(b)}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\For{$i = 1$ to $t$}

			\State $\mathbf{y}^{(i)} \gets \textsf{encodeProbe}^{\mathcal{O}_{\mathcal{B}^{(b)}}}() $
		
			\State $\mathbf{c_y}^{(i)} \gets \textsf{Probe}( \textsf{psk}, \mathbf{y}^{(i)} )$

		\EndFor

		\State In Device-of-User Model:
		
			\State \hspace{\algorithmicindent} $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}} } ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		\State In Device-of-Domain Model:
		
			\State \hspace{\algorithmicindent} $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_{\mathcal{B}^{(1)}}, \mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}} ( \textsf{csk}, \mathbf{c_x}, \{ \mathbf{c_y}^{(i)} \}_{i=1}^t )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

%\caption{The \textsf{IND-MSV} Game}
\label{fig:ind-msv_game}
\end{figure}

Note that in Device-of-Domain model, a probe oracle is given to the adversary.

\begin{itemize}

	\item $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$: On input an index $i$, it first samples $\mathbf{y}^\prime \getsdollar \textsf{encodeProbe}^{\mathcal{O}_{\textsf{samp}}(i)}$, which uses $\mathcal{O}_{\textsf{samp}}(i)$ to answer biometric queries, and outputs $\textsf{Probe}(\textsf{psk}, \mathbf{y}^\prime )$. 

\end{itemize}

We provide $\mathcal{O}_{\textsf{Probe}}^{\textsf{samp}}(\cdot)$ instead of $\mathcal{O}_{\textsf{Probe}}(\textsf{psk}, \cdot)$. This is to avoid the trivial attack where the adversary probes samples from the oracles $\mathcal{O}_{\mathcal{B}^{(0)}}$ and $\mathcal{O}_{\mathcal{B}^{(1)}}$ and compare the results with $\mathbf{c_x}$.

We define the advantage of an adversary $\mathcal{A}$ in the \textsf{IND-MSV} game of a scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ as
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}^\mathcal{O}} := \left |\Pr[\textsf{IND-MSV}_{\Pi}(\mathcal{A}^\mathcal{O}) \to 1] - \frac{1}{2} \right|.
\]

An authentication scheme $\Pi$ associated with a family of distributions $\mathbb{B}$ is called \emph{indistinguishable against malicious server (IND-MSV)} if for any PPT adversary $\mathcal{A}$,
\[
	\Adv^{\textsf{IND-MSV}}_{\Pi, \mathbb{B}, \mathcal{A}} = \negl.
\]

%-------------------


\section{Security Analysis}
\label{sec:security_analysis}

Given an fh-IPFE scheme \textsf{FE}, we define the \textsf{fh-IND} game in algorithm \ref{alg:ind-fh-IPFE}.

\begin{figure}[h]
\centering

	\begin{minipage}[t]{0.4\textwidth}
	\begin{algorithm}[H]
	\caption{$\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A})$}
	\label{alg:ind-fh-IPFE}
	\begin{algorithmic}[1]
		\State $b \getsdollar \{0, 1\}$

		\State $\textsf{msk}, \textsf{pp} \gets \textsf{FE.Setup}(1^\lambda)$

		\State $\tilde{b} \gets \mathcal{A}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}} ( \textsf{pp} )$

		\State \Return $1_{\tilde{b} = b}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}

\label{fig:ind-fh-IPFE}
\end{figure}

\begin{itemize}

	\item $\mathcal{O}_{\textsf{KeyGen}}(\cdot, \cdot)$: On input pair $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$, it outputs $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{x}^{(b)} )$.

	\item $\mathcal{O}_{\textsf{Enc}}(\cdot, \cdot)$: On input pair $(\mathbf{y}^{(0)}, \mathbf{y}^{(1)})$, it outputs $\textsf{FE.Enc}(\textsf{msk}, \textsf{pp}, \mathbf{y}^{(b)} )$.

\end{itemize}

\noindent To avoid trivial attacks, we consider \emph{admissible adversaries}.

\begin{definition}[Admissible Adversary]

	Let $\mathcal{A}$ be an adversary in an \textsf{fh-IND} game, and let $ (\mathbf{x}_1^{(0)}, \mathbf{x}_1^{(1)}), \cdots, (\mathbf{x}_{Q_K}^{(0)}, \mathbf{x}_{Q_K}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{KeyGen}}$ and $(\mathbf{y}_1^{(0)}, \mathbf{y}_1^{(1)}), \cdots, (\mathbf{y}_{Q_E}^{(0)}, \mathbf{y}_{Q_E}^{(1)})$ be its queries to $\mathcal{O}_{\textsf{Enc}}$.
	We say $\mathcal{A}$ is \emph{admissible} if $\forall i \in [Q_K], \forall j \in [Q_E]$,
\[
	{\mathbf{x}^{(0)}_{i}}^T \mathbf{y}^{(0)}_{j} = {\mathbf{x}^{(1)}_{i}}^T \mathbf{y}^{(1)}_{j}
\]

\end{definition}



\begin{definition}[fh-IND Security]

	An fh-IPFE scheme \textsf{FE} is called fh-IND secure if for any admissible adversary $\mathcal{A}$, the advantage of $\mathcal{A}$ in the fh-IND game in Algorithm \ref{alg:ind-fh-IPFE} is

\[
	\Adv_{\textsf{FE}, \mathcal{A}}^{\textsf{fh-IND}} := \left| \Pr[\textsf{fh-IND}_{\textsf{FE}}(\mathcal{A}) \to 1 ] - \frac{1}{2} \right| = \negl.
\]

\end{definition}


\subsection{fh-IND Security and UF-LoB Security}
\label{sec:ind-uf-lob}

Let $\Pi$ be the authentication scheme instantiated by an fh-IPFE scheme \textsf{FE} as in Section \ref{sec:fh-IPFE-instantiation}.
We see a relation between the fh-IND security of \textsf{FE} and the UF-LoB security of $\Pi$.
To show this, first we define a middle game for UF-LoB security in Algorithm \ref{alg:uf-lob-star_game}. The difference is that the adversary $\mathcal{A}$ has no access to $\mathcal{O}_\mathcal{B}$.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\textsf{UF-LoB}^*_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A})$}
	\label{alg:uf-lob-star_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\textsf{esk}, \textsf{psk}, \textsf{csk} \gets \textsf{Setup}(1^\lambda)$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{c_x} \gets \textsf{Enroll}(\textsf{esk}, \mathbf{x})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_\textsf{samp}, \mathcal{O}_\textsf{auth}^q } ( \mathbf{c_x}, \textsf{option})$

		\State $s \gets \textsf{Compare}( \textsf{csk}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\State \Return $\textsf{Verify}(s)$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:uf-lob-star_game}
\end{figure}


\begin{theorem}
\label{thm:ind-uf-lob1}

	For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure, then $\forall \mathcal{A}$ in the \textsf{UF-LoB} game where the auxiliary information \textsf{option} is either nothing or the oracle $\mathcal{O}_{\textsf{Enroll}}$, there exists an adversary $\mathcal{A}^*$ in the $\textsf{UF-LoB}^*$ game such that
	\[
		\Pr[\textsf{UF-LoB}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] - \Pr[\textsf{UF-LoB}^*_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}^*) \to 1] = \negl.
	\]

\end{theorem}


\begin{proof}
\label{proof:ind-uf-lob1}
	We only prove the case when $\textsf{option}$ includes the oracle $\mathcal{O}_{\textsf{Enroll}}$. The proof can be directly applied when $\textsf{option}$ is empty. Given an adversary $\mathcal{A}$ in the \textsf{UF-LoB} game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:reduction-ind-uf-lob1_game} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{R}$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the oracle $\mathcal{O}_{\mathcal{B}^{(0)}}$

	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Enroll}}( \textsf{esk}, \mathbf{x}^\prime )$: This is simulated by $\mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^\prime, \mathbf{x}^\prime)$ given in the \textsf{fh-IND} game.

\end{itemize}
	
\noindent Note that since $\mathcal{R}$ never calls $\mathcal{O}_{\textsf{Enc}}$, it is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
		\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:reduction-ind-uf-lob1_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$

		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$

		\State $\mathbf{x}^{(0)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$

		\State $\mathbf{x}^{(1)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$

		\State $\mathbf{c_x} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Enroll}} } ( \mathbf{c_x})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:reduction-ind-uf-lob1_game:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:reduction-ind-uf-lob1_game}
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a \textsf{UF-LoB} game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction-ind-uf-lob1_game:verify} is $\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1]$.

If the challenge bit $b = 1$, then $\mathcal{B}^{(1)}$ is never seen by $\mathcal{A}$, and $\mathcal{B}^{(0)}$ has the same distribution as any $\mathcal{B}^* \in \mathbb{B}$ that has never been queried before in the view of $\mathcal{A}$. Let $\mathcal{A}^*$ be an adversary in the $\textsf{UF-LoB}^*$ game which runs $\mathcal{A}$ and simulates oracle $\mathcal{O}_{\mathcal{B}}$ by $\mathcal{O}_{\sf samp}(i^*)$ for some index $i^*$ that is never queried by $\mathcal{A}$ in $\mathcal{O}_{\sf samp}(\cdot)$. The probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction-ind-uf-lob1_game:verify} is $\Pr[ \textsf{UF-LoB}^*(\mathcal{A}^*) \to 1 ]$.

In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1]
	&= \Pr[b = 0] \cdot \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 0] \right)  \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 1] \\
	&= \frac{1}{2} \cdot \left ( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} (1 - \Pr[\textsf{Verify}(s) = 1 \mid b = 0]) \right) \\
	& \quad +  \frac{1}{4} \cdot (1 - \Pr[\textsf{Verify}(s) = 1 \mid b = 1]) \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[ \textsf{UF-LoB}^*(\mathcal{A}^*) \to 1 ] \right)
\end{align*}

\noindent Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1 ] - \frac{1}{2} \right| = \negl$,

\[
	\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[ \textsf{UF-LoB}^*(\mathcal{A}^*) \to 1 ] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \negl.
\]

\end{proof}

For the next theorem, we consider two assumptions for the fh-IPFE scheme \textsf{FE}.

\begin{assumption}
\label{assump:ind-uf-lob:simulator}
	Assume that there exists a simulator $\mathcal{S}$ such that given $\textsf{pp}$, the statistical distance between $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$ and $\mathcal{S}(\textsf{pp})$, where $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$ and $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$, is bounded by $\delta$.
	That is, let $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$ and $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$,
	\[
		\Delta \left( (\textsf{pp}, \textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})), (\textsf{pp}, \mathcal{S}(\textsf{pp}) ) \right) \leq \delta.
	\]
	The distribution of $\textsf{FE.KeyGen}(\textsf{msk}, \textsf{pp}, \mathbf{r})$ is taken over $\textsf{FE.Setup}$, $\textsf{FE.KeyGen}$, and $\mathbf{r}$.

\end{assumption}


\begin{assumption}
\label{assump:ind-uf-lob:decryption}
	Assume that $\forall \mathbf{z}$ and $\forall \mathbf{x} \getsdollar \mathcal{B} \in \mathbb{B}$, functional decryption results of two invocations of $\textsf{FE.KeyGen}( \textsf{msk}, \textsf{pp}, \mathbf{x})$ and $\mathbf{z}$ are the same with a probability bounded below by $1 - \epsilon$.
	That is, let $(\textsf{msk}, \textsf{pp}) \gets \textsf{FE.Setup}(1^\lambda)$, and let $\mathbf{c_x}, \mathbf{c_x}^\prime$ be the results of two invocations of $\textsf{FE.KeyGen}( \textsf{msk}, \textsf{pp}, \mathbf{x})$,
\[
	\Pr \left[
		\textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}, \mathbf{z}) = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c_x}^\prime, \mathbf{z})
	\right] \geq 1 - \epsilon
\]
	The probability is taken over $\textsf{FE.Setup}$ and $\textsf{FE.KeyGen}$.

\end{assumption}


\begin{theorem}
\label{thm:ind-uf-lob2}

Given Assumption \ref{assump:ind-uf-lob:simulator} with a negligible $\delta$ and Assumption \ref{assump:ind-uf-lob:decryption} with a negligible $\epsilon$.
For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure, then $\forall \mathcal{A}^*$ in the $\textsf{UF-LoB}^*$ game where the auxiliary information $\textsf{option}$ is empty, there exists an adversary $\mathcal{A}^\prime$ in the $\textsf{UF}$ game such that 
\[
	\Pr[\textsf{UF-LoB}^*_{\Pi, \mathbb{B}}(\mathcal{A}^*) \to 1] - \Pr[\textsf{UF}_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1] = \negl.
\]

\end{theorem}


\begin{proof}
\label{proof:ind-uf-lob2}

Given an adversary $\mathcal{A}^*$ in the $\textsf{UF-LoB}^*$ game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:reduction-ind-uf-lob2_game} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}^*$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{R}$.
	
	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

\end{itemize}

\noindent Note that since $\mathcal{R}$ never calls $\mathcal{O}_{\textsf{Enc}}$, it is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
		\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:reduction-ind-uf-lob2_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}$

		\State $\mathbf{x} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}}}()$

		\State $\mathbf{r} \getsdollar \mathbb{F}^{k+2}$
		
		\State $\mathbf{c} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{r})$ \label{alg:reduction-ind-uf-lob2_game:c}

		\State ${\mathbf{\tilde{z}}} \gets {\mathcal{A}^*}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_\textsf{auth}^q } ( \mathbf{c})$

		\State $\mathbf{c_x} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}, \mathbf{x})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:reduction-ind-uf-lob2_game:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:reduction-ind-uf-lob2_game}
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a $\textsf{UF-LoB}^*$ game for $\mathcal{A}^*$. Therefore, the probability that $\textsf{Verify}(\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}})) = 1$ is $\Pr[\textsf{UF-LoB}^*(\mathcal{A}^*) \to 1]$. By Assumption \ref{assump:ind-uf-lob:decryption}, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction-ind-uf-lob2_game:verify} is at least
\begin{align*}
	& \Pr \left[ s = \textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}}) \right]  \cdot \Pr \left[ \textsf{Verify}(\textsf{FE.Dec}(\textsf{pp}, \mathbf{c}, \mathbf{\tilde{z}})) = 1 \right] \\
	\geq & \quad (1 - \epsilon) \cdot \Pr[\textsf{UF-LoB}^*(\mathcal{A}^*) \to 1]
\end{align*}

	If the challenge bit $b = 1$, then the statistical distance between $\mathbf{c}$ in Line \ref{alg:reduction-ind-uf-lob2_game:c} and the output of $\mathcal{S}$ from Assumption \ref{assump:ind-uf-lob:simulator} is within $\delta$. Let $\mathcal{A}^\prime$ be an adversary in the $\textsf{UF}$ game which runs $\mathcal{A}^*$ and simulates $\mathbf{c_x}$ by $\mathcal{S}(\textsf{pp})$ from Assumption \ref{assump:ind-uf-lob:simulator} and $\mathcal{O}_{\textsf{auth}}^q$ by running $\textsf{Verify}(\textsf{FE.Dec}(\textsf{pp}, \cdot, \cdot))$. The probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction-ind-uf-lob2_game:verify} is at most $\Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] + \delta$.


In conclusion,
\begin{align*}
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] 
	&= \Pr[b = 0] \cdot \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] + \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 0] \right) \\
	&\quad + \Pr[b = 1] \cdot \frac{1}{2} \Pr[\textsf{Verify}(s) = 0 \mid b = 1] \\
	&= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{Verify}(s) = 1 \mid b = 0] - \Pr[\textsf{Verify}(s) = 1 \mid b = 1] \right) \\
	&\geq \frac{1}{2} + \frac{1}{4} \left( (1-\epsilon) \cdot \Pr[\textsf{UF-LoB}^*(\mathcal{A}^*) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] - \delta \right)
\end{align*}

\noindent Since $\Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \left| \Pr[\textsf{fh-IND}(\mathcal{R}) \to 1] - \frac{1}{2} \right| = \negl$, $\epsilon = \negl$, and $\delta = \negl$,
\[
	\Pr[\textsf{UF-LoB}^*(\mathcal{A}^*) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} + \epsilon + \delta = \negl.
\]

\end{proof}

\begin{corollary}
Given Assumption \ref{assump:ind-uf-lob:simulator} with a negligible $\delta$ and Assumption \ref{assump:ind-uf-lob:decryption} with a negligible $\epsilon$.
	For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure, then $\forall \mathcal{A}$ in the $\textsf{UF-LoB}$ game where the auxiliary information $\textsf{option}$ is empty, there exists an adversary $\mathcal{A}^\prime$ in the $\textsf{UF}$ game such that
\[
	\Pr[\textsf{UF-LoB}_{\Pi, \mathbb{B}, \textsf{option}}(\mathcal{A}) \to 1] - \Pr[\textsf{UF}_{\Pi, \mathbb{B}}(\mathcal{A}^\prime) \to 1] = \negl.
\]
As a result, $\Adv_{\Pi, \mathbb{B}, \mathcal{A}, \textsf{option}}^{\textsf{UF-LoB}} = \negl.$ The authentication scheme is $\textsf{option}$-UF-LoB secure.	

\end{corollary}

\begin{proof}

Given an adversary $\mathcal{A}$ in the \textsf{UF-LoB} game, from Theorem \ref{thm:ind-uf-lob1}, we know there exists a reduction $\mathcal{R}_1$ and an adversary $\mathcal{A}^*$ such that
\[
	\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[ \textsf{UF-LoB}^*(\mathcal{A}^*) \to 1 ] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}_1}^\textsf{fh-IND}
\]

With $\mathcal{A}^*$, from Theorem \ref{thm:ind-uf-lob2}, we know there exists a reduction $\mathcal{R}_2$ and an adversary $\mathcal{A}^\prime$ such that 
\[
	\Pr[\textsf{UF-LoB}^*(\mathcal{A}^*) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}_2}^\textsf{fh-IND} + \epsilon + \delta.
\]

Hence,
\[
	\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] \leq 4 \cdot \left( \Adv_{\textsf{FE}, \mathcal{R}_1}^\textsf{fh-IND} + \Adv_{\textsf{FE}, \mathcal{R}_2}^\textsf{fh-IND} \right) + \epsilon + \delta
\]

Since \textsf{FE} is \textsf{fh-IND} secure and both $\epsilon$ and $\delta$ are negligible,
\[
	\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1] = \negl.
\]

\noindent In particular, since $\Adv_{\Pi, \mathbb{B}, \mathcal{A}}^{\textsf{UF-LoB}} \leq \Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1] - \Pr[\textsf{UF}(\mathcal{A}^\prime) \to 1]$,
\[
	\Adv_{\Pi, \mathbb{B}, \mathcal{A}}^{\textsf{UF-LoB}} = \negl.
\]

\noindent This holds for all PPT adversaries $\mathcal{A}$, so $\Pi$ is UF-LoB secure.

\end{proof}


For $\textsf{option}$ that includes $\mathcal{O}_{\textsf{Probe}}$, we first note that the output of $\textsf{encodeEnroll}$ in Section \ref{sec:fh-IPFE-instantiation} has a special structure. For any $d \in \Z_q$, there exists a vector $\mathbf{y} = (0, 0, \cdots, 0, d, 0)$ such that $\mathbf{x}\mathbf{y}^T = d$ for any $\mathbf{x} \getsdollar \textsf{encodeEnroll}()$.


\begin{theorem}
\label{thm:ind-uf-lob3}

For any distribution family $\mathbb{B}$, if \textsf{FE} is fh-IND secure, then $\forall \mathcal{A}$ in the \textsf{UF-LoB} game where the auxiliary information $\textsf{option}$ includes $\mathcal{O}_\textsf{Probe}$, there exists an adversary $\mathcal{A}^*$ in a $\textsf{UF-LoB}^*$ game such that
\[
	\Pr[\textsf{UF-LoB}_{\Pi, \mathbb{B}, \textsf{O}_{\textsf{Probe}}}(\mathcal{A}) \to 1] - \Pr[\textsf{UF-LoB}^*_{\Pi, \mathbb{B}, \textsf{O}_{\textsf{Probe}} }(\mathcal{A}^* ) \to 1] = \negl.
\]	

\end{theorem}


\begin{proof}
\label{proof:ind-uf-lob3}

Given an adversary $\mathcal{A}$ in the \textsf{UF-LoB} game, consider the reduction adversary $\mathcal{R}$ in Algorithm \ref{alg:reduction1-ind-uf-lob3_game} which plays the \textsf{fh-IND} game. $\mathcal{R}$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{R}$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the oracle $\mathcal{O}_{\mathcal{B}^{(0)}}$

	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}^{(0)}{\mathbf{y}^\prime}^T$ and lets $\mathbf{y}^{\prime\prime} \gets (0, 0, \cdots, 0, d, 0)$ such that $\mathbf{x}^{(1)}{\mathbf{y}^{\prime\prime}}^T = d$. Next, it calls $\mathcal{O}_{\textsf{Enc}}(\mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}})$, which is given by the \textsf{fh-IND} game, and returns the result.

\end{itemize}

\noindent Note that $(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$ is the only query of $\mathcal{R}$ to $\mathcal{O}_{\textsf{KeyGen}}$, and for any query $( \mathbf{y}^\prime, {\mathbf{y}^{\prime\prime}} )$ to $\mathcal{O}_{\textsf{Enc}}$, it satisfies $\mathbf{x}^{(0)}{\mathbf{y}^\prime}^T = \mathbf{x}^{(1)}{\mathbf{y}^{\prime\prime}}^T$. Hence, $\mathcal{R}$ is an admissible adversary.

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{$\mathcal{R}^{\mathcal{O}_{\textsf{KeyGen}}, \mathcal{O}_{\textsf{Enc}}}(\textsf{pp})$}
	\label{alg:reduction1-ind-uf-lob3_game}
	\begin{algorithmic}[1]
		\State $\mathcal{B}^{(0)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(0)}$

		\State $\mathcal{B}^{(1)} \getsdollar \mathbb{B}, \quad \mathbb{B} \gets \mathbb{B} \setminus \mathcal{B}^{(1)}$

		\State $\mathbf{x}^{(0)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(0)}}}()$

		\State $\mathbf{x}^{(1)} \gets \textsf{encodeEnroll}^{\mathcal{O}_{\mathcal{B}^{(1)}}}()$

		\State $\mathbf{c_x} \gets \mathcal{O}_{\textsf{KeyGen}}(\mathbf{x}^{(0)}, \mathbf{x}^{(1)})$

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\mathcal{B}^{(0)}}, \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c_x})$

		\State $s \gets \textsf{FE.Dec}( \textsf{pp}, \mathbf{c_x}, \mathbf{\tilde{z}} )$

		\If{$\textsf{Verify}(s) = 1$} \label{alg:reduction1-ind-uf-lob3_game:verify}
			\State \Return $\tilde{b} = 0$
		\Else
			\State \Return $\tilde{b} \getsdollar \{0, 1\}$
		\EndIf

	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:reduction1-ind-uf-lob3_game}
\end{figure}

If the challenge bit $b = 0$, then $\mathcal{R}$ perfectly simulates a \textsf{UF-LoB} game for $\mathcal{A}$. Therefore, the probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction1-ind-uf-lob3_game:verify} is $\Pr[\textsf{UF-LoB}(\mathcal{A}) \to 1]$.

	For the case when the challenge bit $b = 1$, consider an adversary $\mathcal{A}^*$ in Algorithm \ref{alg:adv-ind-uf-lob3_game} in the $\textsf{UF-LoB}^*$ game. The adversary $\mathcal{A}^*$ runs $\mathcal{A}$ and simulates each oracle in the following way.

\begin{itemize}
	\item $\mathcal{O}_{\textsf{samp}}(i)$: This is sampled by $\mathcal{O}_{\textsf{samp}}(i)$ of $\mathcal{A}$.
	
	\item $\mathcal{O}_{\mathcal{B}}$: This is simulated by the oracle $\mathcal{O}_{\textsf{samp}}(i^*)$, where $i^*$ is an index that is never queried by $\mathcal{A}$ in $\mathcal{O}_{\textsf{samp}}$.

	\item $\mathcal{O}_{\textsf{auth}}^q (\textsf{csk}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}})$: This is simulated by calling $\textsf{Verify}( \textsf{FE.Dec}(\textsf{pp}, \mathbf{\tilde{c_x}}, \mathbf{\tilde{c_y}}) )$.

	\item $\mathcal{O}_{\textsf{Probe}}( \textsf{psk}, \mathbf{y}^\prime )$: It first computes $d \gets \mathbf{x}^{(*)}{\mathbf{y}^\prime}^T$ and let $\mathbf{y}^{\prime\prime} \gets (0, 0, \cdots, 0, d, 0)$. Next, it calls $\mathcal{O}_{\textsf{Probe}} (\textsf{psk}, \mathbf{y}^{\prime\prime} )$ , which is given by the $\textsf{UF-LoB}^*$ game, and returns the result.

\end{itemize}

\begin{figure}[h]
\centering
	
	\begin{minipage}[t]{0.5\linewidth}
	\centering
	\begin{algorithm}[H]
	\caption{${\mathcal{A}^*}^{\mathcal{O}_\textsf{samp}, \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c_x}) $}
	\label{alg:adv-ind-uf-lob3_game}
	\begin{algorithmic}[1]
		\State $\mathbf{x}^{(*)} \gets \textsf{encodeEnroll}^{ \mathcal{O}_\textsf{samp}(i^*)} ()$ 

		\State ${\mathbf{\tilde{z}}} \gets \mathcal{A}^{\mathcal{O}_{\textsf{samp}}, \mathcal{O}_{\textsf{samp}}(i^*), \mathcal{O}_\textsf{auth}^q, \mathcal{O}_{\textsf{Probe}} } ( \mathbf{c_x})$

		\State \Return ${\mathbf{\tilde{z}}}$
	\end{algorithmic}
	\end{algorithm}
	\end{minipage}
	
\label{fig:adv-ind-uf-lob3_game}
\end{figure}

Now, if the challenge bit $b = 1$, then $\mathcal{R}$ perfectly simulates $\mathcal{A}^*$ in the $\textsf{UF-LoB}^*$ game.
The probability that $\textsf{Verify}(s) = 1$ in Line \ref{alg:reduction1-ind-uf-lob3_game:verify} is $\Pr[ \textsf{UF-LoB}_{\mathcal{O}_\textsf{Probe}}^*(\mathcal{A}^*) \to 1 ]$.
Similar to the proof of Theorem \ref{thm:ind-uf-lob1}, we derive
\[
	\Pr[\textsf{fh-IND}(\mathcal{R}) \to 1]
	= \frac{1}{2} + \frac{1}{4} \left( \Pr[\textsf{UF-LoB}_{\mathcal{O}_\textsf{Probe}}(\mathcal{A}) \to 1] - \Pr[ \textsf{UF-LoB}_{\mathcal{O}_\textsf{Probe}}^*(\mathcal{A}^*) \to 1 ] \right)
\]

Therefore,

\[
	\Pr[\textsf{UF-LoB}_{\Pi, \mathbb{B}, \textsf{O}_{\textsf{Probe}}}(\mathcal{A}) \to 1] - \Pr[\textsf{UF-LoB}^*_{\Pi, \mathbb{B}, \textsf{O}_{\textsf{Probe}} }(\mathcal{A}^* ) \to 1] \leq 4 \cdot \Adv_{\textsf{FE}, \mathcal{R}}^\textsf{fh-IND} = \negl.
\]	


\end{proof}

















%-------------------
%% Backup File

% \input{backup.tex}

%-------------------
%% Reference List
\nocite{*}
\printbibliography


\end{document}
